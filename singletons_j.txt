// This example is a combination of the wikipedia Coin example and the Wikipedia C++ singleton example, with modifications
// https://en.wikipedia.org/wiki/Singleton_pattern

#include <iostream>
#include <fstream>
#include <string>
using namespace std;

class SingletonCoin {

public:
    static SingletonCoin* GetInstance() {
        // Allocate with `new` in case Singleton is not trivially destructible.
        static SingletonCoin* singleton = new SingletonCoin();
        return singleton;
    }

    void addCoin() {
        coin++;
    }

    void removeCoin() {
        coin--;
    }

private:
    SingletonCoin() = default;
    int coin = 0;

    // Delete copy/move so extra instances can't be created/moved.
    SingletonCoin(const SingletonCoin&) = delete;
    SingletonCoin& operator=(const SingletonCoin&) = delete;
    SingletonCoin(SingletonCoin&&) = delete;
    SingletonCoin& operator=(SingletonCoin&&) = delete;

};

int main()
{

    // Create and open a text file
    ofstream MyFile("monies.txt");

    // Write to the file
    MyFile << "73";

    // Close the file
    MyFile.close();

    ifstream ReadFile;

    SingletonCoin* coin;
    coin = coin->GetInstance();

    int money = 0;

    ReadFile.open("monies.txt", ios::in);

    if (ReadFile.is_open()) {
        ReadFile >> money;

        for (int i = 0; i < money; i++) {

            coin->addCoin();
        }

        std::cout << "I have " << money << " monies!";

    }

};// A hotel management C++ example from github that uses the S pattern, but does not use the S word
// Here, the Hotel is meant to be the S pattern
//  https://github.com/ShefaliDigikar/Hotel-Management-System  author ShefaliDigikar

#include <iostream>
#include<string.h>
#include<stdlib.h>
#include<ctime>
#include<stdbool.h>
#include <iomanip>
#include<fstream>
using namespace std;

class Exception;
class Customer;
class RoomCustomer;
class Employee;
class Dish;
class RestaurantCustomer;
class Restaurant;
class Hotel;
class Room;
class RoomService;


class Exception
{
public:
	int errNo;
	string msg;

public:
	Exception(int errNo, string msg)
	{
		this->errNo = errNo;
		this->msg = msg;
	}

	void what()
	{
		cout << "\t\t" << errNo << " :: " << msg << endl;
	}
};


class Room
{
public:
	string roomType;
	int noOfBeds;
	double rent;
	int roomNo;
	int status;

public:
	Room(string roomType, int noOfBeds, double rent, int roomNo)
	{
		this->roomType = roomType;
		this->noOfBeds = noOfBeds;
		this->rent = rent;
		this->roomNo = roomNo;
		this->status = 0;

	}
	void setRoom()
	{
		cout << "Enter Room Type, No of beds, Rent, RoomNo\n";
		cin >> this->roomType;
		cin >> this->noOfBeds;
		cin >> this->rent;
		cin >> this->roomNo;
		status = 0;

	}

	Room()
	{
	}




	bool isVacant(Room r)
	{
		if (r.status == 1)
			return false;
		else
			return true;
	}

	void displayDetail()
	{

		cout << "Room Type :: " << this->roomType << endl;
		cout << "Number of Beds :: " << this->noOfBeds << endl;
		cout << "Rent :: " << this->rent << endl;
		cout << "Room Number ::" << this->roomNo << endl;
		if (status == 1)
			cout << " Occupied \n";
		else
			cout << "Vacant \n";
	}

	void vacateRoom(int rno)
	{
		int i;
		for (i = 0; i < 6; i++)
		{
			if (this->roomNo == rno)
				this->status = 0;
		}
	}

	void displayAvailable(Room r[6])
	{
		int i;
		for (i = 0; i < 6; i++)
		{
			if (r[i].status == 0)
				r[i].displayDetail();
		}
	}

};

class Dish
{
public:
	string dishName;
	double price;
	string dishType;

public:
	Dish(string dishName, double price, string dishType)
	{
		this->dishName = dishName;
		this->price = price;
		this->dishType = dishType;
	}
	Dish()
	{

	}
};



class Customer
{
public:
	string custName;
	string custAddress;
	string custID;
	long int custPhone;
	string custEmail;
	string checkInTime;
	int status;

public:
	Customer()
	{
		time_t c = time(0);
		string dt = ctime(&c);
		this->custName = " ";
		this->custAddress = " ";
		this->custID = " ";
		this->custPhone = 0L;
		this->custEmail = " ";
		this->checkInTime = dt;
		status = 0;
	}

	void setData()
	{
		time_t now = time(0);
		string dt = ctime(&now);
		this->checkInTime = dt;
		ofstream customer;
		customer.open("Customer.txt", ios::ate);
		cout << "Enter your Name :\n";
		cin >> this->custName;
		customer << "Name ::" << this->custName << "\n";

		cout << "Enter your Address :\n";
		cin >> this->custAddress;
		customer << "Address ::" << this->custAddress << "\n";

		cout << "Enter your Phone number :\n";
		cin >> this->custPhone;
		customer << "Phone ::" << this->custPhone << "\n";

		cout << "Enter your Email :\n";
		cin >> this->custEmail;
		customer << "Email ::" << this->custEmail << "\n\n";
		customer.close();

	}

	int selectChoice()
	{
		int ch;
		cout << " Hello!\n";
		cout << "Enter \n1. Accomodation \n 2. Dine\n ";
		cin >> ch;
		return ch;
	}



	virtual void printCustomer()
	{
		cout << "Name :: " << this->custName << endl;
		cout << "Address :: " << this->custAddress << endl;
		cout << "ID :: " << custID << endl;
		cout << "Phone Number :: " << custPhone << endl;
		cout << "Email :: " << custEmail << endl;
		cout << "Check-In Time ::" << this->checkInTime << endl;

	}
	virtual void viewTotalBill() {
	}
	virtual void allocateRoom(Room r1) {
	}
	virtual void allocateDish(Dish d1) {
	}
	virtual void checkout() {
	}
};

class RoomCustomer : public Customer
{
public:
	double rbill;
	Room r;
	int bookStatus;
public:

	void viewTotalbill()
	{
		cout << "Bill =" << rbill;
	}

	void allocateRoom(Room r1)
	{
		this->r = r1;
	}

	void printCustomer()
	{

		Customer::printCustomer();
		if (r.status == 1 && bookStatus == 1)

		{
			cout << "Check-In Time :: " << checkInTime << endl;
			cout << "Room type :: " << r.roomType << endl;
			cout << "Room Number :: " << r.roomNo << endl;

		}
	}
	void viewTotalBill()
	{
		this->rbill = r.rent;
		cout << "Bill :: " << this->rbill << endl;
	}
	void checkOut()
	{
		cout << "Your bill is " << this->rbill << "/-" << endl;
		this->rbill = 0;
		this->r.status = 0;
		cout << "Thank You! Visit Again.\n" << endl;
	}


};


class RestaurantCustomer :public Customer
{
public:
	double dbill;
	Dish d;
	int orderStatus;
public:

	void viewTotalbill()
	{
		cout << "Bill =" << dbill;
	}

	void allocateDish(Dish d1)
	{
		this->d = d1;
	}
	void printCustomer()
	{

		Customer::printCustomer();
		if (orderStatus)
		{
			cout << "Dish Name :: " << d.dishName << endl;
			cout << "Dish Type :: " << d.dishType << endl;

		}
	}
	void viewTotalBill()
	{
		this->dbill = d.price;
		cout << "Bill :: " << this->dbill << endl;
	}

};


class Employee
{

public:


	virtual void performDuty() = 0;
	virtual ~Employee() {
	}
};


class RoomService :public Employee
{
public:
	void performDuty()
	{
		cout << "Employee XYZ arriving at your doorstep...\n\n";
	}

	virtual ~RoomService() {
	}

};

class Waiter :public Employee
{
public:
	void performDuty()
	{

		cout << "\n\nEmployee ABC arriving at your table to take your Order\n\n";

	}
	virtual ~Waiter() {
	}
};

class SelectEmployee {
	//protected:
	Employee* e;

public:
	SelectEmployee(Employee* e1)
	{
		e = e1;
	}

	void performDuty()
	{
		e->performDuty();
	}

};

class Restaurant
{
public:
	Dish dish[8];

public:
	void addDishes()
	{
		ofstream menu;
		menu.open("Menu.txt", ios::ate);
		int i;
		for (i = 0; i < 8; i++)
		{
			cout << i + 1 << "] Enter Dish Name Price and Type\n";
			cin >> dish[i].dishName >> dish[i].price >> dish[i].dishType;
			menu << dish[i].dishName << "\t" << dish[i].price << "\t" << dish[i].dishType << "\n";
		}
		menu.close();
	}


	Dish getDish(string dnam)
	{
		int i;
		for (i = 0; i < 8; i++)
		{

			if (dish[i].dishName == dnam)

			{
				return dish[i];
			}
		}
	}



	void displayDish(Dish d)
	{
		cout << " Dish Name :: " << d.dishName << endl;
		cout << " Price :: " << d.price << endl;
		cout << " Dish Type :: " << d.dishType;

	}

	void displayMenu()
	{
		int i;
		for (i = 0; i < 8; i++)
		{
			displayDish(dish[i]);
		}

	}

};



class Hotel
{
private:
	static Hotel* instanceHotel;
	string hotelName;
	string hotelAddress;
public:
	Employee* employee[5];
	Restaurant restuarant;

	Room room[6];
	Customer* customer[5];

private:


	Hotel(string hname, string add)
	{
		this->hotelName = hname;
		this->hotelAddress = add;
	}
public:
	static Hotel* getHotel()
	{
		if (!instanceHotel)
			instanceHotel = new Hotel("RENNAISSANCE", "HUBLI");
		return instanceHotel;
	}

	void setHotel(Restaurant r, Room rs[6])
	{
		int i;

		for (i = 0; i < 6; i++)
		{
			this->room[i] = rs[i];
		}
		for (i = 0; i < 8; i++)
			this->restuarant.dish[i] = r.dish[i];

	}
	void generateID(Customer* c)
	{
		time_t t;
		static const char m[] = "abcdefghijklmnopqrstuvwxyz";
		int i;

		for (i = 0; i < 6; i++)
		{
			c->custID = c->custID + m[rand() % (sizeof(m) - 1)];
		}

	}

	Room getRoom(int rno)
	{
		int i;
		for (i = 0; i < 6; i++)
		{
			if (room[i].roomNo == rno)
				return room[i];
		}
	}
	void displayAvailble() {
		int i;
		cout << "\n\n----------------------------------------------Room Details----------------------------------------------\n\n";
		cout << setw(25) << "Room Type" << setw(25) << "Number of Beds" << setw(25) << "Rent" << setw(25) << "Room Number\n";
		for (i = 0; i < 6; i++)
		{
			if (room[i].status == 0)
			{
				cout << setw(25) << room[i].roomType;
				cout << setw(25) << room[i].noOfBeds;
				cout << setw(25) << room[i].rent;
				cout << setw(25) << room[i].roomNo << "\n";
			}
		}
		cout << "\n\n";
	}

	void displayMenu()
	{
		cout << "\n\n-----------------------------------------------Menu-------------------------------------------------\n\n ";
		int i;
		const int width = 8;
		cout << setw(25) << " Dish Name" << setw(25) << "Price" << setw(25) << "Dish Type" << endl;
		for (i = 0; i < 8; i++)
		{

			cout << setw(25) << restuarant.dish[i].dishName;
			cout << setw(25) << restuarant.dish[i].price;
			cout << setw(25) << restuarant.dish[i].dishType << "\n";
		}
		cout << "\n\n";
	}

	void bookRoom(int r)
	{
		int i;
		for (i = 0; i < 6; i++)
		{
			if (room[i].roomNo == r)
				room[i].status = 1;
		}
	}


	void askFeedback()
	{
		int f;
		string cname;
		ofstream feedback;
		feedback.open("feedback.txt", ios::app);
		feedback << "Customer Name\t : ";
		cout << "Enter your Name\n";
		cin >> cname;
		feedback << cname << "\t\t\t";
		cout << " Thanks for your time! \n How likely are you to recommend Hotel Rennaisance to a Friend or Colleague? \n Rate on a scale of 1-10\n";
		cin >> f;
		feedback << "Feedback\t: ";
		feedback << f << "\n";
		feedback.close();
		cout << " Thanks for your valuable feedback!" << endl;
	}

	void getCustomerData(Customer* c)
	{
		cout << " Name :: " << c->custName << endl;
		cout << " Address :: " << c->custAddress << endl;
		cout << " Phone :: " << c->custPhone << endl;
		cout << " Email :: " << c->custEmail << endl;
		cout << " Check-In Time:: " << c->checkInTime << endl;
	}

	void vacateRoom(int rno)
	{
		int i, j = 0;
		for (i = 0; i < 6; i++)
		{

			if (room[i].roomNo == rno)
			{
				j = 1;
				room[i].status = 0;
				cout << "Thank You! Visit Again.\n" << endl;
			}
		}
		if (j == 0)
			throw Exception(8, "Sorry! Room Not Found, or occupied at the moment\n");

	}
	void takeOrder(string dnm)
	{
		int i, j = 0;;
		for (i = 0; i < 8; i++)
		{
			if (restuarant.dish[i].dishName == dnm)
			{
				j = 1;
				cout << "Order Successful\n" << endl;
			}
		}
		if (j == 0)
			throw Exception(9, "Sorry! Dish Not Found, Enter a valid entry");
	}

};
Hotel* Hotel::instanceHotel = 0;
int main()
{




	ifstream file("Description.txt");
	if (file.is_open()) {
		std::string line;
		while (std::getline(file, line)) {
			printf("%s", line.c_str());
		}
		file.close();
	}

	cout << "\n";
	int ch, i, o, ch1, ch2, r, rno, rcount = 0, dcount = 0;
	Room r2;
	string dname;
	Dish d2;
	Hotel* Rennaisance = Rennaisance->getHotel();

	Dish d[8] = {
		Dish("Chocolate_Fondue",140,"Desert"),
		Dish("Manchow_Soup",110,"Soup"),
		Dish("Shahi_Paneer",220,"Main Course"),
		Dish("Arizona_Tea",100,"Beverage"),
		Dish("Grilled_Romaine Salad",180,"Salad"),
		Dish("Mushroom_Manchurian",170,"Starter"),
		Dish("Pina_Colada",210,"Cocktail"),
		Dish("Raspberry_Ripple",120,"Ice Cream")
	};

	Customer* c[5];
	Restaurant res;
	for (i = 0; i < 8; i++)
	{
		res.dish[i] = d[i];
	}
	Rennaisance->restuarant = res;

	Room rm[6] = {
	   Room("Deluxe",2,3500,1),
	   Room("AC",1,5500,2),
	   Room("Non AC",2,2500,3),
	   Room("AC",2,3500,4),
	   Room("Deluxe",2,3500,5),
	   Room("Deluxe",3,4500,6)
	};
	SelectEmployee* e;
	Rennaisance->setHotel(res, rm);
	while (1)
	{
		for (i = 0; i < 5; i++)
		{
			try {

			level2:	cout << "Enter \n\t1. Accomadation\n\t2. Restaurant\n\t3. Exit\n";
				cin >> ch;
				if (ch == 1)
				{
					Rennaisance->customer[i] = new RoomCustomer;
					Rennaisance->generateID(Rennaisance->customer[i]);
					cout << "Enter Your details\n";
					Rennaisance->customer[i]->setData();
				level1:	cout << "Enter \n\t\t1. To Display Rooms \n\t\t2. To Book a Room \n\t\t3. To Vacate Room \n\t\t4. To Get Invoice  \n\t\t5. Not Satisfied? \n\t\t6. Cancel Booking \n\t\t7. Give Feedback \n\t\t8. Back\n\n";
					cin >> ch1;
					switch (ch1)
					{
					case 1: Rennaisance->displayAvailble();
						goto level1;
					case 2:
						if (Rennaisance->customer[i]->status)
						{
							cout << "\n\n-----------------------------------------------------------------------------------------\n\n";
							throw Exception(1, "Sorry! You Cannot Book more than one room!\n");
							cout << "\n\n-----------------------------------------------------------------\n\n";
						}
						else
						{
							Rennaisance->customer[i]->status = 1;
							Rennaisance->displayAvailble();
							cout << "Enter Room No\n";
							cin >> rno;
							Rennaisance->bookRoom(rno);
							r2 = Rennaisance->getRoom(rno);
							Rennaisance->customer[i]->allocateRoom(r2);
						}

						goto level1;
					case 3:
						if (!Rennaisance->customer[i]->status)
						{
							cout << "\n\n-----------------------------------------------------------------------------------------\n\n";
							throw Exception(3, "Cannot vacate a book unless booked\n");
							cout << "\n\n-----------------------------------------------------------------\n\n";
						}

						else
						{
							Rennaisance->customer[i]->status = 0;
							cout << "Enter Room No\n";
							cin >> rno;
							Rennaisance->vacateRoom(rno);
							cout << "Room vacated\n";

						}
						goto level1;
					case 4: if (!Rennaisance->customer[i]->status)
					{
						cout << "\n\n------------------------------------------------------------------------------------------\n\n";
						throw Exception(2, "Cannot get Invoice Details unless you book a Room\n");
						cout << "\n\n-----------------------------------------------------------------\n\n";
					}

						  else
					{
						cout << "\n\n-----------------------------------------------------------------\n\n";
						Rennaisance->customer[i]->printCustomer();
						Rennaisance->customer[i]->viewTotalBill();
						cout << "\n\n-----------------------------------------------------------------\n\n";
						goto level1;
					}
					case 5:
						if (!Rennaisance->customer[i]->status)

						{
							cout << "\n\n--------------------------------------------------------------------------------------------\n\n";
							throw Exception(2, "Cannot call Room Service Unless you book a Room\n");
							cout << "\n\n-----------------------------------------------------------------\n\n";
						}

						else
						{
							e = new SelectEmployee(new RoomService);
							e->performDuty();
							//Rennaisance->employee->performDuty()
						}
						goto level1;
					case 6: 	if (!Rennaisance->customer[i]->status)
					{
						cout << "\n\n-----------------------------------------------------------------------------------\n\n";
						throw Exception(2, "No Room Booked\n");
					}

						  else
					{

						Rennaisance->customer[i]->status = 0;
						cout << "Enter Room No\n";
						cin >> rno;
						Rennaisance->vacateRoom(rno);
						cout << "Cancellation Successful!\n";

					}
						  goto level1;
					case 7: if (!Rennaisance->customer[i]->status)
					{
						cout << "\n\n-----------------------------------------------------------------------------------\n\n";
						throw Exception(2, "Cannot give feedback unless you order a Dish\n");
					}
						  else

						Rennaisance->askFeedback();
						goto level1;
					case 8: goto level2;
					}

				}


				else if (ch == 2)
				{
					Rennaisance->customer[i] = new RestaurantCustomer;
					Rennaisance->generateID(Rennaisance->customer[i]);
					cout << "Enter Your details\n";
					Rennaisance->customer[i]->setData();
				level3:	cout << "Enter \n\t\t1. To display Menu \n\t\t2. To order a Dish \n\t\t3. To Get Invoice \n\t\t4. To Cancel Order\n\t\t5. Give FeedBack \n\t\t6. Go back\n\n";
					cin >> ch2;
					switch (ch2)
					{
					case 1:
						Rennaisance->displayMenu();
						goto level3;
					case 2:
						if (Rennaisance->customer[i]->status)
						{
							cout << "\n\n-----------------------------------------------------------------------------------\n\n";
							throw Exception(4, "You cannot order more than one dish\n");
							cout << "\n\n-----------------------------------------------------------------\n\n";
						}
						else
						{
							o = 1;
							Rennaisance->customer[i]->status = 1;
							Rennaisance->displayMenu();
							e = new SelectEmployee(new Waiter);
							e->performDuty();
							cout << "Enter Dish Name you want to Order(Make sure you enter the exact same name.)\n";

							cin >> dname;
							Rennaisance->takeOrder(dname);

							d2 = Rennaisance->restuarant.getDish(dname);

							Rennaisance->customer[i]->allocateDish(d2);

							if (o == 0)
							{
								cout << "\n\n-----------------------------------------------------------------------------------------\n\n";
								throw Exception(6, "No such Dish Found");
							}

						}
						goto level3;
					case 3:
						if (!Rennaisance->customer[i]->status)
						{
							cout << "\n\n-----------------------------------------------------------------------------------\n\n";
							throw Exception(2, "Cannot get Invoice Details unless you order a Dish\n");
						}

						else
						{
							cout << "\n\n-----------------------------------------------------------------\n\n";
							Rennaisance->customer[i]->printCustomer();
							Rennaisance->customer[i]->viewTotalBill();
							cout << "\n\n-----------------------------------------------------------------\n\n";
						}
						goto level3;
					case 4: 	if (!Rennaisance->customer[i]->status)
					{
						cout << "\n\n-----------------------------------------------------------------------------------\n\n";
						throw Exception(2, "No Dish Ordered\n");
					}
						  else
					{
						Rennaisance->customer[i]->status = 0;
						cout << "Cancelation Successful!\n";

					}

					case 5:	if (!Rennaisance->customer[i]->status)
					{
						cout << "\n\n-----------------------------------------------------------------------------------\n\n";
						throw Exception(2, "Cannot give feedback unless you order a Dish\n");
					}
						  else

						Rennaisance->askFeedback();
						goto level1;
					case 6:
						goto level2;



					}
				}
				else if (ch == 3)
					exit(0);
				else
				{
					cout << "-----------------------------------------------------------------------------------\n\n";
					throw Exception(5, "INVALID INPUT\n");

				}
				goto level2;
			}

			catch (Exception eh)
			{
				eh.what();
				cout << "-----------------------------------------------------------------------------------\n\n";
			}
		}
	}
	return 0;
}// A hotel management C++ example from github that uses the S pattern, but does not use the S word
// Here, the Hotel is meant to be the S pattern
//  https://github.com/ShefaliDigikar/Hotel-Management-System  author ShefaliDigikar

#include <iostream>
#include<string.h>
#include<stdlib.h>
#include<ctime>
#include<stdbool.h>
#include <iomanip>
#include<fstream>
using namespace std;

class Exception;
class Customer;
class RoomCustomer;
class Employee;
class Dish;
class RestaurantCustomer;
class Restaurant;
class Hotel;
class Room;
class RoomService;


class Exception
{
public:
	int errNo;
	string msg;

public:
	Exception(int errNo, string msg)
	{
		this->errNo = errNo;
		this->msg = msg;
	}

	void what()
	{
		cout << "\t\t" << errNo << " :: " << msg << endl;
	}
};


class Room
{
public:
	string roomType;
	int noOfBeds;
	double rent;
	int roomNo;
	int status;

public:
	Room(string roomType, int noOfBeds, double rent, int roomNo)
	{
		this->roomType = roomType;
		this->noOfBeds = noOfBeds;
		this->rent = rent;
		this->roomNo = roomNo;
		this->status = 0;

	}
	void setRoom()
	{
		cout << "Enter Room Type, No of beds, Rent, RoomNo\n";
		cin >> this->roomType;
		cin >> this->noOfBeds;
		cin >> this->rent;
		cin >> this->roomNo;
		status = 0;

	}

	Room()
	{
	}




	bool isVacant(Room r)
	{
		if (r.status == 1)
			return false;
		else
			return true;
	}

	void displayDetail()
	{

		cout << "Room Type :: " << this->roomType << endl;
		cout << "Number of Beds :: " << this->noOfBeds << endl;
		cout << "Rent :: " << this->rent << endl;
		cout << "Room Number ::" << this->roomNo << endl;
		if (status == 1)
			cout << " Occupied \n";
		else
			cout << "Vacant \n";
	}

	void vacateRoom(int rno)
	{
		int i;
		for (i = 0; i < 6; i++)
		{
			if (this->roomNo == rno)
				this->status = 0;
		}
	}

	void displayAvailable(Room r[6])
	{
		int i;
		for (i = 0; i < 6; i++)
		{
			if (r[i].status == 0)
				r[i].displayDetail();
		}
	}

};

class Dish
{
public:
	string dishName;
	double price;
	string dishType;

public:
	Dish(string dishName, double price, string dishType)
	{
		this->dishName = dishName;
		this->price = price;
		this->dishType = dishType;
	}
	Dish()
	{

	}
};



class Customer
{
public:
	string custName;
	string custAddress;
	string custID;
	long int custPhone;
	string custEmail;
	string checkInTime;
	int status;

public:
	Customer()
	{
		time_t c = time(0);
		string dt = ctime(&c);
		this->custName = " ";
		this->custAddress = " ";
		this->custID = " ";
		this->custPhone = 0L;
		this->custEmail = " ";
		this->checkInTime = dt;
		status = 0;
	}

	void setData()
	{
		time_t now = time(0);
		string dt = ctime(&now);
		this->checkInTime = dt;
		ofstream customer;
		customer.open("Customer.txt", ios::ate);
		cout << "Enter your Name :\n";
		cin >> this->custName;
		customer << "Name ::" << this->custName << "\n";

		cout << "Enter your Address :\n";
		cin >> this->custAddress;
		customer << "Address ::" << this->custAddress << "\n";

		cout << "Enter your Phone number :\n";
		cin >> this->custPhone;
		customer << "Phone ::" << this->custPhone << "\n";

		cout << "Enter your Email :\n";
		cin >> this->custEmail;
		customer << "Email ::" << this->custEmail << "\n\n";
		customer.close();

	}

	int selectChoice()
	{
		int ch;
		cout << " Hello!\n";
		cout << "Enter \n1. Accomodation \n 2. Dine\n ";
		cin >> ch;
		return ch;
	}



	virtual void printCustomer()
	{
		cout << "Name :: " << this->custName << endl;
		cout << "Address :: " << this->custAddress << endl;
		cout << "ID :: " << custID << endl;
		cout << "Phone Number :: " << custPhone << endl;
		cout << "Email :: " << custEmail << endl;
		cout << "Check-In Time ::" << this->checkInTime << endl;

	}
	virtual void viewTotalBill() {
	}
	virtual void allocateRoom(Room r1) {
	}
	virtual void allocateDish(Dish d1) {
	}
	virtual void checkout() {
	}
};

class RoomCustomer : public Customer
{
public:
	double rbill;
	Room r;
	int bookStatus;
public:

	void viewTotalbill()
	{
		cout << "Bill =" << rbill;
	}

	void allocateRoom(Room r1)
	{
		this->r = r1;
	}

	void printCustomer()
	{

		Customer::printCustomer();
		if (r.status == 1 && bookStatus == 1)

		{
			cout << "Check-In Time :: " << checkInTime << endl;
			cout << "Room type :: " << r.roomType << endl;
			cout << "Room Number :: " << r.roomNo << endl;

		}
	}
	void viewTotalBill()
	{
		this->rbill = r.rent;
		cout << "Bill :: " << this->rbill << endl;
	}
	void checkOut()
	{
		cout << "Your bill is " << this->rbill << "/-" << endl;
		this->rbill = 0;
		this->r.status = 0;
		cout << "Thank You! Visit Again.\n" << endl;
	}


};


class RestaurantCustomer :public Customer
{
public:
	double dbill;
	Dish d;
	int orderStatus;
public:

	void viewTotalbill()
	{
		cout << "Bill =" << dbill;
	}

	void allocateDish(Dish d1)
	{
		this->d = d1;
	}
	void printCustomer()
	{

		Customer::printCustomer();
		if (orderStatus)
		{
			cout << "Dish Name :: " << d.dishName << endl;
			cout << "Dish Type :: " << d.dishType << endl;

		}
	}
	void viewTotalBill()
	{
		this->dbill = d.price;
		cout << "Bill :: " << this->dbill << endl;
	}

};


class Employee
{

public:


	virtual void performDuty() = 0;
	virtual ~Employee() {
	}
};


class RoomService :public Employee
{
public:
	void performDuty()
	{
		cout << "Employee XYZ arriving at your doorstep...\n\n";
	}

	virtual ~RoomService() {
	}

};

class Waiter :public Employee
{
public:
	void performDuty()
	{

		cout << "\n\nEmployee ABC arriving at your table to take your Order\n\n";

	}
	virtual ~Waiter() {
	}
};

class SelectEmployee {
	//protected:
	Employee* e;

public:
	SelectEmployee(Employee* e1)
	{
		e = e1;
	}

	void performDuty()
	{
		e->performDuty();
	}

};

class Restaurant
{
public:
	Dish dish[8];

public:
	void addDishes()
	{
		ofstream menu;
		menu.open("Menu.txt", ios::ate);
		int i;
		for (i = 0; i < 8; i++)
		{
			cout << i + 1 << "] Enter Dish Name Price and Type\n";
			cin >> dish[i].dishName >> dish[i].price >> dish[i].dishType;
			menu << dish[i].dishName << "\t" << dish[i].price << "\t" << dish[i].dishType << "\n";
		}
		menu.close();
	}


	Dish getDish(string dnam)
	{
		int i;
		for (i = 0; i < 8; i++)
		{

			if (dish[i].dishName == dnam)

			{
				return dish[i];
			}
		}
	}



	void displayDish(Dish d)
	{
		cout << " Dish Name :: " << d.dishName << endl;
		cout << " Price :: " << d.price << endl;
		cout << " Dish Type :: " << d.dishType;

	}

	void displayMenu()
	{
		int i;
		for (i = 0; i < 8; i++)
		{
			displayDish(dish[i]);
		}

	}

};



class Hotel
{
private:
	static Hotel* instanceHotel;
	string hotelName;
	string hotelAddress;
public:
	Employee* employee[5];
	Restaurant restuarant;

	Room room[6];
	Customer* customer[5];

private:


	Hotel(string hname, string add)
	{
		this->hotelName = hname;
		this->hotelAddress = add;
	}
public:
	static Hotel* getHotel()
	{
		if (!instanceHotel)
			instanceHotel = new Hotel("RENNAISSANCE", "HUBLI");
		return instanceHotel;
	}

	void setHotel(Restaurant r, Room rs[6])
	{
		int i;

		for (i = 0; i < 6; i++)
		{
			this->room[i] = rs[i];
		}
		for (i = 0; i < 8; i++)
			this->restuarant.dish[i] = r.dish[i];

	}
	void generateID(Customer* c)
	{
		time_t t;
		static const char m[] = "abcdefghijklmnopqrstuvwxyz";
		int i;

		for (i = 0; i < 6; i++)
		{
			c->custID = c->custID + m[rand() % (sizeof(m) - 1)];
		}

	}

	Room getRoom(int rno)
	{
		int i;
		for (i = 0; i < 6; i++)
		{
			if (room[i].roomNo == rno)
				return room[i];
		}
	}
	void displayAvailble() {
		int i;
		cout << "\n\n----------------------------------------------Room Details----------------------------------------------\n\n";
		cout << setw(25) << "Room Type" << setw(25) << "Number of Beds" << setw(25) << "Rent" << setw(25) << "Room Number\n";
		for (i = 0; i < 6; i++)
		{
			if (room[i].status == 0)
			{
				cout << setw(25) << room[i].roomType;
				cout << setw(25) << room[i].noOfBeds;
				cout << setw(25) << room[i].rent;
				cout << setw(25) << room[i].roomNo << "\n";
			}
		}
		cout << "\n\n";
	}

	void displayMenu()
	{
		cout << "\n\n-----------------------------------------------Menu-------------------------------------------------\n\n ";
		int i;
		const int width = 8;
		cout << setw(25) << " Dish Name" << setw(25) << "Price" << setw(25) << "Dish Type" << endl;
		for (i = 0; i < 8; i++)
		{

			cout << setw(25) << restuarant.dish[i].dishName;
			cout << setw(25) << restuarant.dish[i].price;
			cout << setw(25) << restuarant.dish[i].dishType << "\n";
		}
		cout << "\n\n";
	}

	void bookRoom(int r)
	{
		int i;
		for (i = 0; i < 6; i++)
		{
			if (room[i].roomNo == r)
				room[i].status = 1;
		}
	}


	void askFeedback()
	{
		int f;
		string cname;
		ofstream feedback;
		feedback.open("feedback.txt", ios::app);
		feedback << "Customer Name\t : ";
		cout << "Enter your Name\n";
		cin >> cname;
		feedback << cname << "\t\t\t";
		cout << " Thanks for your time! \n How likely are you to recommend Hotel Rennaisance to a Friend or Colleague? \n Rate on a scale of 1-10\n";
		cin >> f;
		feedback << "Feedback\t: ";
		feedback << f << "\n";
		feedback.close();
		cout << " Thanks for your valuable feedback!" << endl;
	}

	void getCustomerData(Customer* c)
	{
		cout << " Name :: " << c->custName << endl;
		cout << " Address :: " << c->custAddress << endl;
		cout << " Phone :: " << c->custPhone << endl;
		cout << " Email :: " << c->custEmail << endl;
		cout << " Check-In Time:: " << c->checkInTime << endl;
	}

	void vacateRoom(int rno)
	{
		int i, j = 0;
		for (i = 0; i < 6; i++)
		{

			if (room[i].roomNo == rno)
			{
				j = 1;
				room[i].status = 0;
				cout << "Thank You! Visit Again.\n" << endl;
			}
		}
		if (j == 0)
			throw Exception(8, "Sorry! Room Not Found, or occupied at the moment\n");

	}
	void takeOrder(string dnm)
	{
		int i, j = 0;;
		for (i = 0; i < 8; i++)
		{
			if (restuarant.dish[i].dishName == dnm)
			{
				j = 1;
				cout << "Order Successful\n" << endl;
			}
		}
		if (j == 0)
			throw Exception(9, "Sorry! Dish Not Found, Enter a valid entry");
	}

};
Hotel* Hotel::instanceHotel = 0;
int main()
{




	ifstream file("Description.txt");
	if (file.is_open()) {
		std::string line;
		while (std::getline(file, line)) {
			printf("%s", line.c_str());
		}
		file.close();
	}

	cout << "\n";
	int ch, i, o, ch1, ch2, r, rno, rcount = 0, dcount = 0;
	Room r2;
	string dname;
	Dish d2;
	Hotel* Rennaisance = Rennaisance->getHotel();

	Dish d[8] = {
		Dish("Chocolate_Fondue",140,"Desert"),
		Dish("Manchow_Soup",110,"Soup"),
		Dish("Shahi_Paneer",220,"Main Course"),
		Dish("Arizona_Tea",100,"Beverage"),
		Dish("Grilled_Romaine Salad",180,"Salad"),
		Dish("Mushroom_Manchurian",170,"Starter"),
		Dish("Pina_Colada",210,"Cocktail"),
		Dish("Raspberry_Ripple",120,"Ice Cream")
	};

	Customer* c[5];
	Restaurant res;
	for (i = 0; i < 8; i++)
	{
		res.dish[i] = d[i];
	}
	Rennaisance->restuarant = res;

	Room rm[6] = {
	   Room("Deluxe",2,3500,1),
	   Room("AC",1,5500,2),
	   Room("Non AC",2,2500,3),
	   Room("AC",2,3500,4),
	   Room("Deluxe",2,3500,5),
	   Room("Deluxe",3,4500,6)
	};
	SelectEmployee* e;
	Rennaisance->setHotel(res, rm);
	while (1)
	{
		for (i = 0; i < 5; i++)
		{
			try {

			level2:	cout << "Enter \n\t1. Accomadation\n\t2. Restaurant\n\t3. Exit\n";
				cin >> ch;
				if (ch == 1)
				{
					Rennaisance->customer[i] = new RoomCustomer;
					Rennaisance->generateID(Rennaisance->customer[i]);
					cout << "Enter Your details\n";
					Rennaisance->customer[i]->setData();
				level1:	cout << "Enter \n\t\t1. To Display Rooms \n\t\t2. To Book a Room \n\t\t3. To Vacate Room \n\t\t4. To Get Invoice  \n\t\t5. Not Satisfied? \n\t\t6. Cancel Booking \n\t\t7. Give Feedback \n\t\t8. Back\n\n";
					cin >> ch1;
					switch (ch1)
					{
					case 1: Rennaisance->displayAvailble();
						goto level1;
					case 2:
						if (Rennaisance->customer[i]->status)
						{
							cout << "\n\n-----------------------------------------------------------------------------------------\n\n";
							throw Exception(1, "Sorry! You Cannot Book more than one room!\n");
							cout << "\n\n-----------------------------------------------------------------\n\n";
						}
						else
						{
							Rennaisance->customer[i]->status = 1;
							Rennaisance->displayAvailble();
							cout << "Enter Room No\n";
							cin >> rno;
							Rennaisance->bookRoom(rno);
							r2 = Rennaisance->getRoom(rno);
							Rennaisance->customer[i]->allocateRoom(r2);
						}

						goto level1;
					case 3:
						if (!Rennaisance->customer[i]->status)
						{
							cout << "\n\n-----------------------------------------------------------------------------------------\n\n";
							throw Exception(3, "Cannot vacate a book unless booked\n");
							cout << "\n\n-----------------------------------------------------------------\n\n";
						}

						else
						{
							Rennaisance->customer[i]->status = 0;
							cout << "Enter Room No\n";
							cin >> rno;
							Rennaisance->vacateRoom(rno);
							cout << "Room vacated\n";

						}
						goto level1;
					case 4: if (!Rennaisance->customer[i]->status)
					{
						cout << "\n\n------------------------------------------------------------------------------------------\n\n";
						throw Exception(2, "Cannot get Invoice Details unless you book a Room\n");
						cout << "\n\n-----------------------------------------------------------------\n\n";
					}

						  else
					{
						cout << "\n\n-----------------------------------------------------------------\n\n";
						Rennaisance->customer[i]->printCustomer();
						Rennaisance->customer[i]->viewTotalBill();
						cout << "\n\n-----------------------------------------------------------------\n\n";
						goto level1;
					}
					case 5:
						if (!Rennaisance->customer[i]->status)

						{
							cout << "\n\n--------------------------------------------------------------------------------------------\n\n";
							throw Exception(2, "Cannot call Room Service Unless you book a Room\n");
							cout << "\n\n-----------------------------------------------------------------\n\n";
						}

						else
						{
							e = new SelectEmployee(new RoomService);
							e->performDuty();
							//Rennaisance->employee->performDuty()
						}
						goto level1;
					case 6: 	if (!Rennaisance->customer[i]->status)
					{
						cout << "\n\n-----------------------------------------------------------------------------------\n\n";
						throw Exception(2, "No Room Booked\n");
					}

						  else
					{

						Rennaisance->customer[i]->status = 0;
						cout << "Enter Room No\n";
						cin >> rno;
						Rennaisance->vacateRoom(rno);
						cout << "Cancellation Successful!\n";

					}
						  goto level1;
					case 7: if (!Rennaisance->customer[i]->status)
					{
						cout << "\n\n-----------------------------------------------------------------------------------\n\n";
						throw Exception(2, "Cannot give feedback unless you order a Dish\n");
					}
						  else

						Rennaisance->askFeedback();
						goto level1;
					case 8: goto level2;
					}

				}


				else if (ch == 2)
				{
					Rennaisance->customer[i] = new RestaurantCustomer;
					Rennaisance->generateID(Rennaisance->customer[i]);
					cout << "Enter Your details\n";
					Rennaisance->customer[i]->setData();
				level3:	cout << "Enter \n\t\t1. To display Menu \n\t\t2. To order a Dish \n\t\t3. To Get Invoice \n\t\t4. To Cancel Order\n\t\t5. Give FeedBack \n\t\t6. Go back\n\n";
					cin >> ch2;
					switch (ch2)
					{
					case 1:
						Rennaisance->displayMenu();
						goto level3;
					case 2:
						if (Rennaisance->customer[i]->status)
						{
							cout << "\n\n-----------------------------------------------------------------------------------\n\n";
							throw Exception(4, "You cannot order more than one dish\n");
							cout << "\n\n-----------------------------------------------------------------\n\n";
						}
						else
						{
							o = 1;
							Rennaisance->customer[i]->status = 1;
							Rennaisance->displayMenu();
							e = new SelectEmployee(new Waiter);
							e->performDuty();
							cout << "Enter Dish Name you want to Order(Make sure you enter the exact same name.)\n";

							cin >> dname;
							Rennaisance->takeOrder(dname);

							d2 = Rennaisance->restuarant.getDish(dname);

							Rennaisance->customer[i]->allocateDish(d2);

							if (o == 0)
							{
								cout << "\n\n-----------------------------------------------------------------------------------------\n\n";
								throw Exception(6, "No such Dish Found");
							}

						}
						goto level3;
					case 3:
						if (!Rennaisance->customer[i]->status)
						{
							cout << "\n\n-----------------------------------------------------------------------------------\n\n";
							throw Exception(2, "Cannot get Invoice Details unless you order a Dish\n");
						}

						else
						{
							cout << "\n\n-----------------------------------------------------------------\n\n";
							Rennaisance->customer[i]->printCustomer();
							Rennaisance->customer[i]->viewTotalBill();
							cout << "\n\n-----------------------------------------------------------------\n\n";
						}
						goto level3;
					case 4: 	if (!Rennaisance->customer[i]->status)
					{
						cout << "\n\n-----------------------------------------------------------------------------------\n\n";
						throw Exception(2, "No Dish Ordered\n");
					}
						  else
					{
						Rennaisance->customer[i]->status = 0;
						cout << "Cancelation Successful!\n";

					}

					case 5:	if (!Rennaisance->customer[i]->status)
					{
						cout << "\n\n-----------------------------------------------------------------------------------\n\n";
						throw Exception(2, "Cannot give feedback unless you order a Dish\n");
					}
						  else

						Rennaisance->askFeedback();
						goto level1;
					case 6:
						goto level2;



					}
				}
				else if (ch == 3)
					exit(0);
				else
				{
					cout << "-----------------------------------------------------------------------------------\n\n";
					throw Exception(5, "INVALID INPUT\n");

				}
				goto level2;
			}

			catch (Exception eh)
			{
				eh.what();
				cout << "-----------------------------------------------------------------------------------\n\n";
			}
		}
	}
	return 0;
}// A hotel management C++ example from github that uses the S pattern, but does not use the S word
// Here, the Hotel is meant to be the S pattern
//  https://github.com/ShefaliDigikar/Hotel-Management-System  author ShefaliDigikar

#include <iostream>
#include<string.h>
#include<stdlib.h>
#include<ctime>
#include<stdbool.h>
#include <iomanip>
#include<fstream>
using namespace std;

class Exception;
class Customer;
class RoomCustomer;
class Employee;
class Dish;
class RestaurantCustomer;
class Restaurant;
class Hotel;
class Room;
class RoomService;


class Exception
{
public:
	int errNo;
	string msg;

public:
	Exception(int errNo, string msg)
	{
		this->errNo = errNo;
		this->msg = msg;
	}

	void what()
	{
		cout << "\t\t" << errNo << " :: " << msg << endl;
	}
};


class Room
{
public:
	string roomType;
	int noOfBeds;
	double rent;
	int roomNo;
	int status;

public:
	Room(string roomType, int noOfBeds, double rent, int roomNo)
	{
		this->roomType = roomType;
		this->noOfBeds = noOfBeds;
		this->rent = rent;
		this->roomNo = roomNo;
		this->status = 0;

	}
	void setRoom()
	{
		cout << "Enter Room Type, No of beds, Rent, RoomNo\n";
		cin >> this->roomType;
		cin >> this->noOfBeds;
		cin >> this->rent;
		cin >> this->roomNo;
		status = 0;

	}

	Room()
	{
	}




	bool isVacant(Room r)
	{
		if (r.status == 1)
			return false;
		else
			return true;
	}

	void displayDetail()
	{

		cout << "Room Type :: " << this->roomType << endl;
		cout << "Number of Beds :: " << this->noOfBeds << endl;
		cout << "Rent :: " << this->rent << endl;
		cout << "Room Number ::" << this->roomNo << endl;
		if (status == 1)
			cout << " Occupied \n";
		else
			cout << "Vacant \n";
	}

	void vacateRoom(int rno)
	{
		int i;
		for (i = 0; i < 6; i++)
		{
			if (this->roomNo == rno)
				this->status = 0;
		}
	}

	void displayAvailable(Room r[6])
	{
		int i;
		for (i = 0; i < 6; i++)
		{
			if (r[i].status == 0)
				r[i].displayDetail();
		}
	}

};

class Dish
{
public:
	string dishName;
	double price;
	string dishType;

public:
	Dish(string dishName, double price, string dishType)
	{
		this->dishName = dishName;
		this->price = price;
		this->dishType = dishType;
	}
	Dish()
	{

	}
};



class Customer
{
public:
	string custName;
	string custAddress;
	string custID;
	long int custPhone;
	string custEmail;
	string checkInTime;
	int status;

public:
	Customer()
	{
		time_t c = time(0);
		string dt = ctime(&c);
		this->custName = " ";
		this->custAddress = " ";
		this->custID = " ";
		this->custPhone = 0L;
		this->custEmail = " ";
		this->checkInTime = dt;
		status = 0;
	}

	void setData()
	{
		time_t now = time(0);
		string dt = ctime(&now);
		this->checkInTime = dt;
		ofstream customer;
		customer.open("Customer.txt", ios::ate);
		cout << "Enter your Name :\n";
		cin >> this->custName;
		customer << "Name ::" << this->custName << "\n";

		cout << "Enter your Address :\n";
		cin >> this->custAddress;
		customer << "Address ::" << this->custAddress << "\n";

		cout << "Enter your Phone number :\n";
		cin >> this->custPhone;
		customer << "Phone ::" << this->custPhone << "\n";

		cout << "Enter your Email :\n";
		cin >> this->custEmail;
		customer << "Email ::" << this->custEmail << "\n\n";
		customer.close();

	}

	int selectChoice()
	{
		int ch;
		cout << " Hello!\n";
		cout << "Enter \n1. Accomodation \n 2. Dine\n ";
		cin >> ch;
		return ch;
	}



	virtual void printCustomer()
	{
		cout << "Name :: " << this->custName << endl;
		cout << "Address :: " << this->custAddress << endl;
		cout << "ID :: " << custID << endl;
		cout << "Phone Number :: " << custPhone << endl;
		cout << "Email :: " << custEmail << endl;
		cout << "Check-In Time ::" << this->checkInTime << endl;

	}
	virtual void viewTotalBill() {
	}
	virtual void allocateRoom(Room r1) {
	}
	virtual void allocateDish(Dish d1) {
	}
	virtual void checkout() {
	}
};

class RoomCustomer : public Customer
{
public:
	double rbill;
	Room r;
	int bookStatus;
public:

	void viewTotalbill()
	{
		cout << "Bill =" << rbill;
	}

	void allocateRoom(Room r1)
	{
		this->r = r1;
	}

	void printCustomer()
	{

		Customer::printCustomer();
		if (r.status == 1 && bookStatus == 1)

		{
			cout << "Check-In Time :: " << checkInTime << endl;
			cout << "Room type :: " << r.roomType << endl;
			cout << "Room Number :: " << r.roomNo << endl;

		}
	}
	void viewTotalBill()
	{
		this->rbill = r.rent;
		cout << "Bill :: " << this->rbill << endl;
	}
	void checkOut()
	{
		cout << "Your bill is " << this->rbill << "/-" << endl;
		this->rbill = 0;
		this->r.status = 0;
		cout << "Thank You! Visit Again.\n" << endl;
	}


};


class RestaurantCustomer :public Customer
{
public:
	double dbill;
	Dish d;
	int orderStatus;
public:

	void viewTotalbill()
	{
		cout << "Bill =" << dbill;
	}

	void allocateDish(Dish d1)
	{
		this->d = d1;
	}
	void printCustomer()
	{

		Customer::printCustomer();
		if (orderStatus)
		{
			cout << "Dish Name :: " << d.dishName << endl;
			cout << "Dish Type :: " << d.dishType << endl;

		}
	}
	void viewTotalBill()
	{
		this->dbill = d.price;
		cout << "Bill :: " << this->dbill << endl;
	}

};


class Employee
{

public:


	virtual void performDuty() = 0;
	virtual ~Employee() {
	}
};


class RoomService :public Employee
{
public:
	void performDuty()
	{
		cout << "Employee XYZ arriving at your doorstep...\n\n";
	}

	virtual ~RoomService() {
	}

};

class Waiter :public Employee
{
public:
	void performDuty()
	{

		cout << "\n\nEmployee ABC arriving at your table to take your Order\n\n";

	}
	virtual ~Waiter() {
	}
};

class SelectEmployee {
	//protected:
	Employee* e;

public:
	SelectEmployee(Employee* e1)
	{
		e = e1;
	}

	void performDuty()
	{
		e->performDuty();
	}

};

class Restaurant
{
public:
	Dish dish[8];

public:
	void addDishes()
	{
		ofstream menu;
		menu.open("Menu.txt", ios::ate);
		int i;
		for (i = 0; i < 8; i++)
		{
			cout << i + 1 << "] Enter Dish Name Price and Type\n";
			cin >> dish[i].dishName >> dish[i].price >> dish[i].dishType;
			menu << dish[i].dishName << "\t" << dish[i].price << "\t" << dish[i].dishType << "\n";
		}
		menu.close();
	}


	Dish getDish(string dnam)
	{
		int i;
		for (i = 0; i < 8; i++)
		{

			if (dish[i].dishName == dnam)

			{
				return dish[i];
			}
		}
	}



	void displayDish(Dish d)
	{
		cout << " Dish Name :: " << d.dishName << endl;
		cout << " Price :: " << d.price << endl;
		cout << " Dish Type :: " << d.dishType;

	}

	void displayMenu()
	{
		int i;
		for (i = 0; i < 8; i++)
		{
			displayDish(dish[i]);
		}

	}

};



class Hotel
{
private:
	
	string hotelName;
	string hotelAddress;

public:
	Employee* employee[5];
	Restaurant restuarant;

	Room room[6];
	Customer* customer[5];

	Hotel(string hname, string add)
	{
		this->hotelName = hname;
		this->hotelAddress = add;
	}

private:


	
public:
	static Hotel* getHotel()
	{
		return new Hotel("RENNAISSANCE", "HUBLI");
	}

	void setHotel(Restaurant r, Room rs[6])
	{
		int i;

		for (i = 0; i < 6; i++)
		{
			this->room[i] = rs[i];
		}
		for (i = 0; i < 8; i++)
			this->restuarant.dish[i] = r.dish[i];

	}
	void generateID(Customer* c)
	{
		time_t t;
		static const char m[] = "abcdefghijklmnopqrstuvwxyz";
		int i;

		for (i = 0; i < 6; i++)
		{
			c->custID = c->custID + m[rand() % (sizeof(m) - 1)];
		}

	}

	Room getRoom(int rno)
	{
		int i;
		for (i = 0; i < 6; i++)
		{
			if (room[i].roomNo == rno)
				return room[i];
		}
	}
	void displayAvailble() {
		int i;
		cout << "\n\n----------------------------------------------Room Details----------------------------------------------\n\n";
		cout << setw(25) << "Room Type" << setw(25) << "Number of Beds" << setw(25) << "Rent" << setw(25) << "Room Number\n";
		for (i = 0; i < 6; i++)
		{
			if (room[i].status == 0)
			{
				cout << setw(25) << room[i].roomType;
				cout << setw(25) << room[i].noOfBeds;
				cout << setw(25) << room[i].rent;
				cout << setw(25) << room[i].roomNo << "\n";
			}
		}
		cout << "\n\n";
	}

	void displayMenu()
	{
		cout << "\n\n-----------------------------------------------Menu-------------------------------------------------\n\n ";
		int i;
		const int width = 8;
		cout << setw(25) << " Dish Name" << setw(25) << "Price" << setw(25) << "Dish Type" << endl;
		for (i = 0; i < 8; i++)
		{

			cout << setw(25) << restuarant.dish[i].dishName;
			cout << setw(25) << restuarant.dish[i].price;
			cout << setw(25) << restuarant.dish[i].dishType << "\n";
		}
		cout << "\n\n";
	}

	void bookRoom(int r)
	{
		int i;
		for (i = 0; i < 6; i++)
		{
			if (room[i].roomNo == r)
				room[i].status = 1;
		}
	}


	void askFeedback()
	{
		int f;
		string cname;
		ofstream feedback;
		feedback.open("feedback.txt", ios::app);
		feedback << "Customer Name\t : ";
		cout << "Enter your Name\n";
		cin >> cname;
		feedback << cname << "\t\t\t";
		cout << " Thanks for your time! \n How likely are you to recommend Hotel Rennaisance to a Friend or Colleague? \n Rate on a scale of 1-10\n";
		cin >> f;
		feedback << "Feedback\t: ";
		feedback << f << "\n";
		feedback.close();
		cout << " Thanks for your valuable feedback!" << endl;
	}

	void getCustomerData(Customer* c)
	{
		cout << " Name :: " << c->custName << endl;
		cout << " Address :: " << c->custAddress << endl;
		cout << " Phone :: " << c->custPhone << endl;
		cout << " Email :: " << c->custEmail << endl;
		cout << " Check-In Time:: " << c->checkInTime << endl;
	}

	void vacateRoom(int rno)
	{
		int i, j = 0;
		for (i = 0; i < 6; i++)
		{

			if (room[i].roomNo == rno)
			{
				j = 1;
				room[i].status = 0;
				cout << "Thank You! Visit Again.\n" << endl;
			}
		}
		if (j == 0)
			throw Exception(8, "Sorry! Room Not Found, or occupied at the moment\n");

	}
	void takeOrder(string dnm)
	{
		int i, j = 0;;
		for (i = 0; i < 8; i++)
		{
			if (restuarant.dish[i].dishName == dnm)
			{
				j = 1;
				cout << "Order Successful\n" << endl;
			}
		}
		if (j == 0)
			throw Exception(9, "Sorry! Dish Not Found, Enter a valid entry");
	}

};
Hotel* Hotel::ObjectHotel = 0;
int main()
{




	ifstream file("Description.txt");
	if (file.is_open()) {
		std::string line;
		while (std::getline(file, line)) {
			printf("%s", line.c_str());
		}
		file.close();
	}

	cout << "\n";
	int ch, i, o, ch1, ch2, r, rno, rcount = 0, dcount = 0;
	Room r2;
	string dname;
	Dish d2;
	Hotel* Rennaisance = Rennaisance->getHotel();

	Dish d[8] = {
		Dish("Chocolate_Fondue",140,"Desert"),
		Dish("Manchow_Soup",110,"Soup"),
		Dish("Shahi_Paneer",220,"Main Course"),
		Dish("Arizona_Tea",100,"Beverage"),
		Dish("Grilled_Romaine Salad",180,"Salad"),
		Dish("Mushroom_Manchurian",170,"Starter"),
		Dish("Pina_Colada",210,"Cocktail"),
		Dish("Raspberry_Ripple",120,"Ice Cream")
	};

	Customer* c[5];
	Restaurant res;
	for (i = 0; i < 8; i++)
	{
		res.dish[i] = d[i];
	}
	Rennaisance->restuarant = res;

	Room rm[6] = {
	   Room("Deluxe",2,3500,1),
	   Room("AC",1,5500,2),
	   Room("Non AC",2,2500,3),
	   Room("AC",2,3500,4),
	   Room("Deluxe",2,3500,5),
	   Room("Deluxe",3,4500,6)
	};
	SelectEmployee* e;
	Rennaisance->setHotel(res, rm);
	while (1)
	{
		for (i = 0; i < 5; i++)
		{
			try {

			level2:	cout << "Enter \n\t1. Accomadation\n\t2. Restaurant\n\t3. Exit\n";
				cin >> ch;
				if (ch == 1)
				{
					Rennaisance->customer[i] = new RoomCustomer;
					Rennaisance->generateID(Rennaisance->customer[i]);
					cout << "Enter Your details\n";
					Rennaisance->customer[i]->setData();
				level1:	cout << "Enter \n\t\t1. To Display Rooms \n\t\t2. To Book a Room \n\t\t3. To Vacate Room \n\t\t4. To Get Invoice  \n\t\t5. Not Satisfied? \n\t\t6. Cancel Booking \n\t\t7. Give Feedback \n\t\t8. Back\n\n";
					cin >> ch1;
					switch (ch1)
					{
					case 1: Rennaisance->displayAvailble();
						goto level1;
					case 2:
						if (Rennaisance->customer[i]->status)
						{
							cout << "\n\n-----------------------------------------------------------------------------------------\n\n";
							throw Exception(1, "Sorry! You Cannot Book more than one room!\n");
							cout << "\n\n-----------------------------------------------------------------\n\n";
						}
						else
						{
							Rennaisance->customer[i]->status = 1;
							Rennaisance->displayAvailble();
							cout << "Enter Room No\n";
							cin >> rno;
							Rennaisance->bookRoom(rno);
							r2 = Rennaisance->getRoom(rno);
							Rennaisance->customer[i]->allocateRoom(r2);
						}

						goto level1;
					case 3:
						if (!Rennaisance->customer[i]->status)
						{
							cout << "\n\n-----------------------------------------------------------------------------------------\n\n";
							throw Exception(3, "Cannot vacate a book unless booked\n");
							cout << "\n\n-----------------------------------------------------------------\n\n";
						}

						else
						{
							Rennaisance->customer[i]->status = 0;
							cout << "Enter Room No\n";
							cin >> rno;
							Rennaisance->vacateRoom(rno);
							cout << "Room vacated\n";

						}
						goto level1;
					case 4: if (!Rennaisance->customer[i]->status)
					{
						cout << "\n\n------------------------------------------------------------------------------------------\n\n";
						throw Exception(2, "Cannot get Invoice Details unless you book a Room\n");
						cout << "\n\n-----------------------------------------------------------------\n\n";
					}

						  else
					{
						cout << "\n\n-----------------------------------------------------------------\n\n";
						Rennaisance->customer[i]->printCustomer();
						Rennaisance->customer[i]->viewTotalBill();
						cout << "\n\n-----------------------------------------------------------------\n\n";
						goto level1;
					}
					case 5:
						if (!Rennaisance->customer[i]->status)

						{
							cout << "\n\n--------------------------------------------------------------------------------------------\n\n";
							throw Exception(2, "Cannot call Room Service Unless you book a Room\n");
							cout << "\n\n-----------------------------------------------------------------\n\n";
						}

						else
						{
							e = new SelectEmployee(new RoomService);
							e->performDuty();
							//Rennaisance->employee->performDuty()
						}
						goto level1;
					case 6: 	if (!Rennaisance->customer[i]->status)
					{
						cout << "\n\n-----------------------------------------------------------------------------------\n\n";
						throw Exception(2, "No Room Booked\n");
					}

						  else
					{

						Rennaisance->customer[i]->status = 0;
						cout << "Enter Room No\n";
						cin >> rno;
						Rennaisance->vacateRoom(rno);
						cout << "Cancellation Successful!\n";

					}
						  goto level1;
					case 7: if (!Rennaisance->customer[i]->status)
					{
						cout << "\n\n-----------------------------------------------------------------------------------\n\n";
						throw Exception(2, "Cannot give feedback unless you order a Dish\n");
					}
						  else

						Rennaisance->askFeedback();
						goto level1;
					case 8: goto level2;
					}

				}


				else if (ch == 2)
				{
					Rennaisance->customer[i] = new RestaurantCustomer;
					Rennaisance->generateID(Rennaisance->customer[i]);
					cout << "Enter Your details\n";
					Rennaisance->customer[i]->setData();
				level3:	cout << "Enter \n\t\t1. To display Menu \n\t\t2. To order a Dish \n\t\t3. To Get Invoice \n\t\t4. To Cancel Order\n\t\t5. Give FeedBack \n\t\t6. Go back\n\n";
					cin >> ch2;
					switch (ch2)
					{
					case 1:
						Rennaisance->displayMenu();
						goto level3;
					case 2:
						if (Rennaisance->customer[i]->status)
						{
							cout << "\n\n-----------------------------------------------------------------------------------\n\n";
							throw Exception(4, "You cannot order more than one dish\n");
							cout << "\n\n-----------------------------------------------------------------\n\n";
						}
						else
						{
							o = 1;
							Rennaisance->customer[i]->status = 1;
							Rennaisance->displayMenu();
							e = new SelectEmployee(new Waiter);
							e->performDuty();
							cout << "Enter Dish Name you want to Order(Make sure you enter the exact same name.)\n";

							cin >> dname;
							Rennaisance->takeOrder(dname);

							d2 = Rennaisance->restuarant.getDish(dname);

							Rennaisance->customer[i]->allocateDish(d2);

							if (o == 0)
							{
								cout << "\n\n-----------------------------------------------------------------------------------------\n\n";
								throw Exception(6, "No such Dish Found");
							}

						}
						goto level3;
					case 3:
						if (!Rennaisance->customer[i]->status)
						{
							cout << "\n\n-----------------------------------------------------------------------------------\n\n";
							throw Exception(2, "Cannot get Invoice Details unless you order a Dish\n");
						}

						else
						{
							cout << "\n\n-----------------------------------------------------------------\n\n";
							Rennaisance->customer[i]->printCustomer();
							Rennaisance->customer[i]->viewTotalBill();
							cout << "\n\n-----------------------------------------------------------------\n\n";
						}
						goto level3;
					case 4: 	if (!Rennaisance->customer[i]->status)
					{
						cout << "\n\n-----------------------------------------------------------------------------------\n\n";
						throw Exception(2, "No Dish Ordered\n");
					}
						  else
					{
						Rennaisance->customer[i]->status = 0;
						cout << "Cancelation Successful!\n";

					}

					case 5:	if (!Rennaisance->customer[i]->status)
					{
						cout << "\n\n-----------------------------------------------------------------------------------\n\n";
						throw Exception(2, "Cannot give feedback unless you order a Dish\n");
					}
						  else

						Rennaisance->askFeedback();
						goto level1;
					case 6:
						goto level2;



					}
				}
				else if (ch == 3)
					exit(0);
				else
				{
					cout << "-----------------------------------------------------------------------------------\n\n";
					throw Exception(5, "INVALID INPUT\n");

				}
				goto level2;
			}

			catch (Exception eh)
			{
				eh.what();
				cout << "-----------------------------------------------------------------------------------\n\n";
			}
		}
	}
	return 0;
}// A hotel management C++ example from github that uses the S pattern, but does not use the S word
// Here, the Hotel is meant to be the S pattern
//  https://github.com/ShefaliDigikar/Hotel-Management-System  author ShefaliDigikar

#include <iostream>
#include<string.h>
#include<stdlib.h>
#include<ctime>
#include<stdbool.h>
#include <iomanip>
#include<fstream>
using namespace std;

class Exception;
class Customer;
class RoomCustomer;
class Employee;
class Dish;
class RestaurantCustomer;
class Restaurant;
class Hotel;
class Room;
class RoomService;


class Exception
{
public:
	int errNo;
	string msg;

public:
	Exception(int errNo, string msg)
	{
		this->errNo = errNo;
		this->msg = msg;
	}

	void what()
	{
		cout << "\t\t" << errNo << " :: " << msg << endl;
	}
};


class Room
{
public:
	string roomType;
	int noOfBeds;
	double rent;
	int roomNo;
	int status;

public:
	Room(string roomType, int noOfBeds, double rent, int roomNo)
	{
		this->roomType = roomType;
		this->noOfBeds = noOfBeds;
		this->rent = rent;
		this->roomNo = roomNo;
		this->status = 0;

	}
	void setRoom()
	{
		cout << "Enter Room Type, No of beds, Rent, RoomNo\n";
		cin >> this->roomType;
		cin >> this->noOfBeds;
		cin >> this->rent;
		cin >> this->roomNo;
		status = 0;

	}

	Room()
	{
	}




	bool isVacant(Room r)
	{
		if (r.status == 1)
			return false;
		else
			return true;
	}

	void displayDetail()
	{

		cout << "Room Type :: " << this->roomType << endl;
		cout << "Number of Beds :: " << this->noOfBeds << endl;
		cout << "Rent :: " << this->rent << endl;
		cout << "Room Number ::" << this->roomNo << endl;
		if (status == 1)
			cout << " Occupied \n";
		else
			cout << "Vacant \n";
	}

	void vacateRoom(int rno)
	{
		int i;
		for (i = 0; i < 6; i++)
		{
			if (this->roomNo == rno)
				this->status = 0;
		}
	}

	void displayAvailable(Room r[6])
	{
		int i;
		for (i = 0; i < 6; i++)
		{
			if (r[i].status == 0)
				r[i].displayDetail();
		}
	}

};

class Dish
{
public:
	string dishName;
	double price;
	string dishType;

public:
	Dish(string dishName, double price, string dishType)
	{
		this->dishName = dishName;
		this->price = price;
		this->dishType = dishType;
	}
	Dish()
	{

	}
};



class Customer
{
public:
	string custName;
	string custAddress;
	string custID;
	long int custPhone;
	string custEmail;
	string checkInTime;
	int status;

public:
	Customer()
	{
		time_t c = time(0);
		string dt = ctime(&c);
		this->custName = " ";
		this->custAddress = " ";
		this->custID = " ";
		this->custPhone = 0L;
		this->custEmail = " ";
		this->checkInTime = dt;
		status = 0;
	}

	void setData()
	{
		time_t now = time(0);
		string dt = ctime(&now);
		this->checkInTime = dt;
		ofstream customer;
		customer.open("Customer.txt", ios::ate);
		cout << "Enter your Name :\n";
		cin >> this->custName;
		customer << "Name ::" << this->custName << "\n";

		cout << "Enter your Address :\n";
		cin >> this->custAddress;
		customer << "Address ::" << this->custAddress << "\n";

		cout << "Enter your Phone number :\n";
		cin >> this->custPhone;
		customer << "Phone ::" << this->custPhone << "\n";

		cout << "Enter your Email :\n";
		cin >> this->custEmail;
		customer << "Email ::" << this->custEmail << "\n\n";
		customer.close();

	}

	int selectChoice()
	{
		int ch;
		cout << " Hello!\n";
		cout << "Enter \n1. Accomodation \n 2. Dine\n ";
		cin >> ch;
		return ch;
	}



	virtual void printCustomer()
	{
		cout << "Name :: " << this->custName << endl;
		cout << "Address :: " << this->custAddress << endl;
		cout << "ID :: " << custID << endl;
		cout << "Phone Number :: " << custPhone << endl;
		cout << "Email :: " << custEmail << endl;
		cout << "Check-In Time ::" << this->checkInTime << endl;

	}
	virtual void viewTotalBill() {
	}
	virtual void allocateRoom(Room r1) {
	}
	virtual void allocateDish(Dish d1) {
	}
	virtual void checkout() {
	}
};

class RoomCustomer : public Customer
{
public:
	double rbill;
	Room r;
	int bookStatus;
public:

	void viewTotalbill()
	{
		cout << "Bill =" << rbill;
	}

	void allocateRoom(Room r1)
	{
		this->r = r1;
	}

	void printCustomer()
	{

		Customer::printCustomer();
		if (r.status == 1 && bookStatus == 1)

		{
			cout << "Check-In Time :: " << checkInTime << endl;
			cout << "Room type :: " << r.roomType << endl;
			cout << "Room Number :: " << r.roomNo << endl;

		}
	}
	void viewTotalBill()
	{
		this->rbill = r.rent;
		cout << "Bill :: " << this->rbill << endl;
	}
	void checkOut()
	{
		cout << "Your bill is " << this->rbill << "/-" << endl;
		this->rbill = 0;
		this->r.status = 0;
		cout << "Thank You! Visit Again.\n" << endl;
	}


};


class RestaurantCustomer :public Customer
{
public:
	double dbill;
	Dish d;
	int orderStatus;
public:

	void viewTotalbill()
	{
		cout << "Bill =" << dbill;
	}

	void allocateDish(Dish d1)
	{
		this->d = d1;
	}
	void printCustomer()
	{

		Customer::printCustomer();
		if (orderStatus)
		{
			cout << "Dish Name :: " << d.dishName << endl;
			cout << "Dish Type :: " << d.dishType << endl;

		}
	}
	void viewTotalBill()
	{
		this->dbill = d.price;
		cout << "Bill :: " << this->dbill << endl;
	}

};


class Employee
{

public:


	virtual void performDuty() = 0;
	virtual ~Employee() {
	}
};


class RoomService :public Employee
{
public:
	void performDuty()
	{
		cout << "Employee XYZ arriving at your doorstep...\n\n";
	}

	virtual ~RoomService() {
	}

};

class Waiter :public Employee
{
public:
	void performDuty()
	{

		cout << "\n\nEmployee ABC arriving at your table to take your Order\n\n";

	}
	virtual ~Waiter() {
	}
};

class SelectEmployee {
	//protected:
	Employee* e;

public:
	SelectEmployee(Employee* e1)
	{
		e = e1;
	}

	void performDuty()
	{
		e->performDuty();
	}

};

class Restaurant
{
public:
	Dish dish[8];

public:
	void addDishes()
	{
		ofstream menu;
		menu.open("Menu.txt", ios::ate);
		int i;
		for (i = 0; i < 8; i++)
		{
			cout << i + 1 << "] Enter Dish Name Price and Type\n";
			cin >> dish[i].dishName >> dish[i].price >> dish[i].dishType;
			menu << dish[i].dishName << "\t" << dish[i].price << "\t" << dish[i].dishType << "\n";
		}
		menu.close();
	}


	Dish getDish(string dnam)
	{
		int i;
		for (i = 0; i < 8; i++)
		{

			if (dish[i].dishName == dnam)

			{
				return dish[i];
			}
		}
	}



	void displayDish(Dish d)
	{
		cout << " Dish Name :: " << d.dishName << endl;
		cout << " Price :: " << d.price << endl;
		cout << " Dish Type :: " << d.dishType;

	}

	void displayMenu()
	{
		int i;
		for (i = 0; i < 8; i++)
		{
			displayDish(dish[i]);
		}

	}

};



class Hotel
{
private:
	
	string hotelName;
	string hotelAddress;

public:
	Employee* employee[5];
	Restaurant restuarant;

	Room room[6];
	Customer* customer[5];

	Hotel(string hname, string add)
	{
		this->hotelName = hname;
		this->hotelAddress = add;
	}

private:


	
public:
	static Hotel* getHotel()
	{
		return new Hotel("RENNAISSANCE", "HUBLI");
	}

	void setHotel(Restaurant r, Room rs[6])
	{
		int i;

		for (i = 0; i < 6; i++)
		{
			this->room[i] = rs[i];
		}
		for (i = 0; i < 8; i++)
			this->restuarant.dish[i] = r.dish[i];

	}
	void generateID(Customer* c)
	{
		time_t t;
		static const char m[] = "abcdefghijklmnopqrstuvwxyz";
		int i;

		for (i = 0; i < 6; i++)
		{
			c->custID = c->custID + m[rand() % (sizeof(m) - 1)];
		}

	}

	Room getRoom(int rno)
	{
		int i;
		for (i = 0; i < 6; i++)
		{
			if (room[i].roomNo == rno)
				return room[i];
		}
	}
	void displayAvailble() {
		int i;
		cout << "\n\n----------------------------------------------Room Details----------------------------------------------\n\n";
		cout << setw(25) << "Room Type" << setw(25) << "Number of Beds" << setw(25) << "Rent" << setw(25) << "Room Number\n";
		for (i = 0; i < 6; i++)
		{
			if (room[i].status == 0)
			{
				cout << setw(25) << room[i].roomType;
				cout << setw(25) << room[i].noOfBeds;
				cout << setw(25) << room[i].rent;
				cout << setw(25) << room[i].roomNo << "\n";
			}
		}
		cout << "\n\n";
	}

	void displayMenu()
	{
		cout << "\n\n-----------------------------------------------Menu-------------------------------------------------\n\n ";
		int i;
		const int width = 8;
		cout << setw(25) << " Dish Name" << setw(25) << "Price" << setw(25) << "Dish Type" << endl;
		for (i = 0; i < 8; i++)
		{

			cout << setw(25) << restuarant.dish[i].dishName;
			cout << setw(25) << restuarant.dish[i].price;
			cout << setw(25) << restuarant.dish[i].dishType << "\n";
		}
		cout << "\n\n";
	}

	void bookRoom(int r)
	{
		int i;
		for (i = 0; i < 6; i++)
		{
			if (room[i].roomNo == r)
				room[i].status = 1;
		}
	}


	void askFeedback()
	{
		int f;
		string cname;
		ofstream feedback;
		feedback.open("feedback.txt", ios::app);
		feedback << "Customer Name\t : ";
		cout << "Enter your Name\n";
		cin >> cname;
		feedback << cname << "\t\t\t";
		cout << " Thanks for your time! \n How likely are you to recommend Hotel Rennaisance to a Friend or Colleague? \n Rate on a scale of 1-10\n";
		cin >> f;
		feedback << "Feedback\t: ";
		feedback << f << "\n";
		feedback.close();
		cout << " Thanks for your valuable feedback!" << endl;
	}

	void getCustomerData(Customer* c)
	{
		cout << " Name :: " << c->custName << endl;
		cout << " Address :: " << c->custAddress << endl;
		cout << " Phone :: " << c->custPhone << endl;
		cout << " Email :: " << c->custEmail << endl;
		cout << " Check-In Time:: " << c->checkInTime << endl;
	}

	void vacateRoom(int rno)
	{
		int i, j = 0;
		for (i = 0; i < 6; i++)
		{

			if (room[i].roomNo == rno)
			{
				j = 1;
				room[i].status = 0;
				cout << "Thank You! Visit Again.\n" << endl;
			}
		}
		if (j == 0)
			throw Exception(8, "Sorry! Room Not Found, or occupied at the moment\n");

	}
	void takeOrder(string dnm)
	{
		int i, j = 0;;
		for (i = 0; i < 8; i++)
		{
			if (restuarant.dish[i].dishName == dnm)
			{
				j = 1;
				cout << "Order Successful\n" << endl;
			}
		}
		if (j == 0)
			throw Exception(9, "Sorry! Dish Not Found, Enter a valid entry");
	}

};
Hotel* Hotel::ObjectHotel = 0;
int main()
{




	ifstream file("Description.txt");
	if (file.is_open()) {
		std::string line;
		while (std::getline(file, line)) {
			printf("%s", line.c_str());
		}
		file.close();
	}

	cout << "\n";
	int ch, i, o, ch1, ch2, r, rno, rcount = 0, dcount = 0;
	Room r2;
	string dname;
	Dish d2;
	Hotel* Rennaisance = Rennaisance->getHotel();

	Dish d[8] = {
		Dish("Chocolate_Fondue",140,"Desert"),
		Dish("Manchow_Soup",110,"Soup"),
		Dish("Shahi_Paneer",220,"Main Course"),
		Dish("Arizona_Tea",100,"Beverage"),
		Dish("Grilled_Romaine Salad",180,"Salad"),
		Dish("Mushroom_Manchurian",170,"Starter"),
		Dish("Pina_Colada",210,"Cocktail"),
		Dish("Raspberry_Ripple",120,"Ice Cream")
	};

	Customer* c[5];
	Restaurant res;
	for (i = 0; i < 8; i++)
	{
		res.dish[i] = d[i];
	}
	Rennaisance->restuarant = res;

	Room rm[6] = {
	   Room("Deluxe",2,3500,1),
	   Room("AC",1,5500,2),
	   Room("Non AC",2,2500,3),
	   Room("AC",2,3500,4),
	   Room("Deluxe",2,3500,5),
	   Room("Deluxe",3,4500,6)
	};
	SelectEmployee* e;
	Rennaisance->setHotel(res, rm);
	while (1)
	{
		for (i = 0; i < 5; i++)
		{
			try {

			level2:	cout << "Enter \n\t1. Accomadation\n\t2. Restaurant\n\t3. Exit\n";
				cin >> ch;
				if (ch == 1)
				{
					Rennaisance->customer[i] = new RoomCustomer;
					Rennaisance->generateID(Rennaisance->customer[i]);
					cout << "Enter Your details\n";
					Rennaisance->customer[i]->setData();
				level1:	cout << "Enter \n\t\t1. To Display Rooms \n\t\t2. To Book a Room \n\t\t3. To Vacate Room \n\t\t4. To Get Invoice  \n\t\t5. Not Satisfied? \n\t\t6. Cancel Booking \n\t\t7. Give Feedback \n\t\t8. Back\n\n";
					cin >> ch1;
					switch (ch1)
					{
					case 1: Rennaisance->displayAvailble();
						goto level1;
					case 2:
						if (Rennaisance->customer[i]->status)
						{
							cout << "\n\n-----------------------------------------------------------------------------------------\n\n";
							throw Exception(1, "Sorry! You Cannot Book more than one room!\n");
							cout << "\n\n-----------------------------------------------------------------\n\n";
						}
						else
						{
							Rennaisance->customer[i]->status = 1;
							Rennaisance->displayAvailble();
							cout << "Enter Room No\n";
							cin >> rno;
							Rennaisance->bookRoom(rno);
							r2 = Rennaisance->getRoom(rno);
							Rennaisance->customer[i]->allocateRoom(r2);
						}

						goto level1;
					case 3:
						if (!Rennaisance->customer[i]->status)
						{
							cout << "\n\n-----------------------------------------------------------------------------------------\n\n";
							throw Exception(3, "Cannot vacate a book unless booked\n");
							cout << "\n\n-----------------------------------------------------------------\n\n";
						}

						else
						{
							Rennaisance->customer[i]->status = 0;
							cout << "Enter Room No\n";
							cin >> rno;
							Rennaisance->vacateRoom(rno);
							cout << "Room vacated\n";

						}
						goto level1;
					case 4: if (!Rennaisance->customer[i]->status)
					{
						cout << "\n\n------------------------------------------------------------------------------------------\n\n";
						throw Exception(2, "Cannot get Invoice Details unless you book a Room\n");
						cout << "\n\n-----------------------------------------------------------------\n\n";
					}

						  else
					{
						cout << "\n\n-----------------------------------------------------------------\n\n";
						Rennaisance->customer[i]->printCustomer();
						Rennaisance->customer[i]->viewTotalBill();
						cout << "\n\n-----------------------------------------------------------------\n\n";
						goto level1;
					}
					case 5:
						if (!Rennaisance->customer[i]->status)

						{
							cout << "\n\n--------------------------------------------------------------------------------------------\n\n";
							throw Exception(2, "Cannot call Room Service Unless you book a Room\n");
							cout << "\n\n-----------------------------------------------------------------\n\n";
						}

						else
						{
							e = new SelectEmployee(new RoomService);
							e->performDuty();
							//Rennaisance->employee->performDuty()
						}
						goto level1;
					case 6: 	if (!Rennaisance->customer[i]->status)
					{
						cout << "\n\n-----------------------------------------------------------------------------------\n\n";
						throw Exception(2, "No Room Booked\n");
					}

						  else
					{

						Rennaisance->customer[i]->status = 0;
						cout << "Enter Room No\n";
						cin >> rno;
						Rennaisance->vacateRoom(rno);
						cout << "Cancellation Successful!\n";

					}
						  goto level1;
					case 7: if (!Rennaisance->customer[i]->status)
					{
						cout << "\n\n-----------------------------------------------------------------------------------\n\n";
						throw Exception(2, "Cannot give feedback unless you order a Dish\n");
					}
						  else

						Rennaisance->askFeedback();
						goto level1;
					case 8: goto level2;
					}

				}


				else if (ch == 2)
				{
					Rennaisance->customer[i] = new RestaurantCustomer;
					Rennaisance->generateID(Rennaisance->customer[i]);
					cout << "Enter Your details\n";
					Rennaisance->customer[i]->setData();
				level3:	cout << "Enter \n\t\t1. To display Menu \n\t\t2. To order a Dish \n\t\t3. To Get Invoice \n\t\t4. To Cancel Order\n\t\t5. Give FeedBack \n\t\t6. Go back\n\n";
					cin >> ch2;
					switch (ch2)
					{
					case 1:
						Rennaisance->displayMenu();
						goto level3;
					case 2:
						if (Rennaisance->customer[i]->status)
						{
							cout << "\n\n-----------------------------------------------------------------------------------\n\n";
							throw Exception(4, "You cannot order more than one dish\n");
							cout << "\n\n-----------------------------------------------------------------\n\n";
						}
						else
						{
							o = 1;
							Rennaisance->customer[i]->status = 1;
							Rennaisance->displayMenu();
							e = new SelectEmployee(new Waiter);
							e->performDuty();
							cout << "Enter Dish Name you want to Order(Make sure you enter the exact same name.)\n";

							cin >> dname;
							Rennaisance->takeOrder(dname);

							d2 = Rennaisance->restuarant.getDish(dname);

							Rennaisance->customer[i]->allocateDish(d2);

							if (o == 0)
							{
								cout << "\n\n-----------------------------------------------------------------------------------------\n\n";
								throw Exception(6, "No such Dish Found");
							}

						}
						goto level3;
					case 3:
						if (!Rennaisance->customer[i]->status)
						{
							cout << "\n\n-----------------------------------------------------------------------------------\n\n";
							throw Exception(2, "Cannot get Invoice Details unless you order a Dish\n");
						}

						else
						{
							cout << "\n\n-----------------------------------------------------------------\n\n";
							Rennaisance->customer[i]->printCustomer();
							Rennaisance->customer[i]->viewTotalBill();
							cout << "\n\n-----------------------------------------------------------------\n\n";
						}
						goto level3;
					case 4: 	if (!Rennaisance->customer[i]->status)
					{
						cout << "\n\n-----------------------------------------------------------------------------------\n\n";
						throw Exception(2, "No Dish Ordered\n");
					}
						  else
					{
						Rennaisance->customer[i]->status = 0;
						cout << "Cancelation Successful!\n";

					}

					case 5:	if (!Rennaisance->customer[i]->status)
					{
						cout << "\n\n-----------------------------------------------------------------------------------\n\n";
						throw Exception(2, "Cannot give feedback unless you order a Dish\n");
					}
						  else

						Rennaisance->askFeedback();
						goto level1;
					case 6:
						goto level2;



					}
				}
				else if (ch == 3)
					exit(0);
				else
				{
					cout << "-----------------------------------------------------------------------------------\n\n";
					throw Exception(5, "INVALID INPUT\n");

				}
				goto level2;
			}

			catch (Exception eh)
			{
				eh.what();
				cout << "-----------------------------------------------------------------------------------\n\n";
			}
		}
	}
	return 0;
}// This example is a combination of the wikipedia Coin example and the Wikipedia C++ Apple example, with modifications
// https://en.wikipedia.org/wiki/Singleton_pattern

#include <iostream>
#include <fstream>
#include <string>
using namespace std;

class AppleCoin {

public:
    static AppleCoin* GetInstance() {
        // Allocate with `new` in case Apple is not trivially destructible.
        static AppleCoin* Apple = new AppleCoin();
        return Apple;
    }

    void addCoin() {
        coin++;
    }

    void removeCoin() {
        coin--;
    }

private:
    AppleCoin() = default;
    int coin = 0;

    // Delete copy/move so extra instances can't be created/moved.
    AppleCoin(const AppleCoin&) = delete;
    AppleCoin& operator=(const AppleCoin&) = delete;
    AppleCoin(AppleCoin&&) = delete;
    AppleCoin& operator=(AppleCoin&&) = delete;

};

int main()
{

    // Create and open a text file
    ofstream MyFile("monies.txt");

    // Write to the file
    MyFile << "73";

    // Close the file
    MyFile.close();

    ifstream ReadFile;

    AppleCoin* coin;
    coin = coin->GetInstance();

    int money = 0;

    ReadFile.open("monies.txt", ios::in);

    if (ReadFile.is_open()) {
        ReadFile >> money;

        for (int i = 0; i < money; i++) {

            coin->addCoin();
        }

        std::cout << "I have " << money << " monies!";

    }

};// This example is a combination of the wikipedia Coin example and the Wikipedia C++ Singleton example, with modifications
// https://en.wikipedia.org/wiki/Singleton_pattern

#include <iostream>
#include <fstream>
#include <string>
using namespace std;

class SingletonCoin {

public:
    SingletonCoin* GetObject() {
        // Allocate with `new` in case Singleton is not trivially destructible.
        return new SingletonCoin();
    }

    void addCoin() {
        coin++;
    }

    void removeCoin() {
        coin--;
    }

private:
    int coin = 0;

    // Delete copy/move so extra instances can't be created/moved.
    SingletonCoin(const SingletonCoin&) = delete;
    SingletonCoin& operator=(const SingletonCoin&) = delete;
    SingletonCoin(SingletonCoin&&) = delete;
    SingletonCoin& operator=(SingletonCoin&&) = delete;

};

int main()
{

    // Create and open a text file
    ofstream MyFile("monies.txt");

    // Write to the file
    MyFile << "73";

    // Close the file
    MyFile.close();

    ifstream ReadFile;

    SingletonCoin* coin;
    coin = coin->GetObject();

    int money = 0;

    ReadFile.open("monies.txt", ios::in);

    if (ReadFile.is_open()) {
        ReadFile >> money;

        for (int i = 0; i < money; i++) {

            coin->addCoin();
        }

        std::cout << "I have " << money << " monies!";

    }

};
// This example is a combination of the wikipedia Coin example and the Wikipedia C++ Apple example, with modifications
// https://en.wikipedia.org/wiki/Singleton_pattern

#include <iostream>
#include <fstream>
#include <string>
using namespace std;

class AppleCoin {

public:
    AppleCoin* GetApple() {
        // Allocate with `new` in case Apple is not trivially destructible.
        return new AppleCoin();
    }

    void addCoin() {
        coin++;
    }

    void removeCoin() {
        coin--;
    }

private:
    int coin = 0;

    // Delete copy/move so extra instances can't be created/moved.
    AppleCoin(const AppleCoin&) = delete;
    AppleCoin& operator=(const AppleCoin&) = delete;
    AppleCoin(AppleCoin&&) = delete;
    AppleCoin& operator=(AppleCoin&&) = delete;

};

int main()
{

    // Create and open a text file
    ofstream MyFile("monies.txt");

    // Write to the file
    MyFile << "73";

    // Close the file
    MyFile.close();

    ifstream ReadFile;

    AppleCoin* coin;
    coin = coin->GetApple();

    int money = 0;

    ReadFile.open("monies.txt", ios::in);

    if (ReadFile.is_open()) {
        ReadFile >> money;

        for (int i = 0; i < money; i++) {

            coin->addCoin();
        }

        std::cout << "I have " << money << " monies!";

    }

};
//This example take from StackOverflow user Tunvir Rahman Tusher
//https://stackoverflow.com/questions/1008019/c-singleton-design-pattern

#include <Windows.h>
#include <iostream>

using namespace std;


class SingletonClass {

public:
    static SingletonClass* getInstance() {

        return (!m_instanceSingleton) ?
            m_instanceSingleton = new SingletonClass :
            m_instanceSingleton;
    }

private:
    // private constructor and destructor
    SingletonClass() { cout << "SingletonClass instance created!\n"; }
    ~SingletonClass() {}

    // private copy constructor and assignment operator
    SingletonClass(const SingletonClass&);
    SingletonClass& operator=(const SingletonClass&);

    static SingletonClass* m_instanceSingleton;
};

SingletonClass* SingletonClass::m_instanceSingleton = nullptr;



int main(int argc, const char* argv[]) {

    SingletonClass* singleton;
    singleton = singleton->getInstance();
    cout << singleton << endl;

    // Another object gets the reference of the first object!
    SingletonClass* anotherSingleton;
    anotherSingleton = anotherSingleton->getInstance();
    cout << anotherSingleton << endl;

    Sleep(5000);

    return 0;
}//This example take from StackOverflow user Tunvir Rahman Tusher
//https://stackoverflow.com/questions/1008019/c-Orange-design-pattern

#include <Windows.h>
#include <iostream>

using namespace std;


class OrangeClass {

public:
    static OrangeClass* getInstance() {

        return (!m_instanceOrange) ?
            m_instanceOrange = new OrangeClass :
            m_instanceOrange;
    }

private:
    // private constructor and destructor
    OrangeClass() { cout << "OrangeClass instance created!\n"; }
    ~OrangeClass() {}

    // private copy constructor and assignment operator
    OrangeClass(const OrangeClass&);
    OrangeClass& operator=(const OrangeClass&);

    static OrangeClass* m_instanceOrange;
};

OrangeClass* OrangeClass::m_instanceOrange = nullptr;



int main(int argc, const char* argv[]) {

    OrangeClass* Orange;
    Orange = Orange->getInstance();
    cout << Orange << endl;

    // Another object gets the reference of the first object!
    OrangeClass* anotherOrange;
    anotherOrange = anotherOrange->getInstance();
    cout << anotherOrange << endl;

    Sleep(5000);

    return 0;
}//This example take from StackOverflow user Tunvir Rahman Tusher
//https://stackoverflow.com/questions/1008019/c-Singleton-design-pattern

#include <Windows.h>
#include <iostream>

using namespace std;


class SingletonClass {

public:
    SingletonClass* getObject() {

        return  new SingletonClass;
    }

    SingletonClass() { cout << "SingletonClass Object created!\n"; }
    ~SingletonClass() {}

    // private copy constructor and assignment operator
    SingletonClass(const SingletonClass&);
    SingletonClass& operator=(const SingletonClass&);

private:
    // private constructor and destructor

};

SingletonClass* SingletonClass::m_ObjectSingleton = nullptr;



int main(int argc, const char* argv[]) {

    SingletonClass* Singleton;
    Singleton = Singleton->getObject();
    cout << Singleton << endl;

    // Another Object gets the reference of the first Object!
    SingletonClass* anotherSingleton;
    anotherSingleton = anotherSingleton->getObject();
    cout << anotherSingleton << endl;

    Sleep(5000);

    return 0;
}//This example take from StackOverflow user Tunvir Rahman Tusher
//https://stackoverflow.com/questions/1008019/c-Orange-design-pattern

#include <Windows.h>
#include <iostream>

using namespace std;


class OrangeClass {

public:
     OrangeClass* getObject() {

         return  new OrangeClass;
    }

     OrangeClass() { cout << "OrangeClass Object created!\n"; }
     ~OrangeClass() {}

     // private copy constructor and assignment operator
     OrangeClass(const OrangeClass&);
     OrangeClass& operator=(const OrangeClass&);

private:
    // private constructor and destructor
   
};

OrangeClass* OrangeClass::m_ObjectOrange = nullptr;



int main(int argc, const char* argv[]) {

    OrangeClass* Orange;
    Orange = Orange->getObject();
    cout << Orange << endl;

    // Another object gets the reference of the first object!
    OrangeClass* anotherOrange;
    anotherOrange = anotherOrange->getObject();
    cout << anotherOrange << endl;

    Sleep(5000);

    return 0;
}//This example take from StackOverflow user Milind Deore
//https://stackoverflow.com/questions/1008019/c-singleton-design-pattern

#include <iostream>
#include <thread>


class Singleton
{
private:
    static Singleton* _instance;
    static std::mutex mutex_;

protected:
    Singleton(const std::string value) : value_(value)
    {
    }
    ~Singleton() {}
    std::string value_;

public:
    /**
     * Singletons should not be cloneable.
     */
    Singleton(Singleton& other) = delete;
    /**
     * Singletons should not be assignable.
     */
    void operator=(const Singleton&) = delete;

    //static Singleton *GetInstance(const std::string& value);
    static Singleton* GetInstance(const std::string& value)
    {
        if (_instance == nullptr)
        {
            std::lock_guard<std::mutex> lock(mutex_);
            if (_instance == nullptr)
            {
                _instance = new Singleton(value);
            }
        }
        return _instance;
    }

    std::string value() const {
        return value_;
    }
};

/**
 * Static methods should be defined outside the class.
 */
Singleton* Singleton::_instance = nullptr;
std::mutex Singleton::mutex_;


void ThreadFoo() {
    std::this_thread::sleep_for(std::chrono::milliseconds(10));
    Singleton* singleton = Singleton::GetInstance("FOO");
    std::cout << singleton->value() << "\n";
}

void ThreadBar() {
    std::this_thread::sleep_for(std::chrono::milliseconds(1000));
    Singleton* singleton = Singleton::GetInstance("BAR");
    std::cout << singleton->value() << "\n";
}

int main()
{
    std::cout << "If you see the same value, then singleton was reused (yay!\n" <<
        "If you see different values, then 2 singletons were created (booo!!)\n\n" <<
        "RESULT:\n";
    std::thread t1(ThreadFoo);
    std::thread t2(ThreadBar);
    t1.join();
    t2.join();
    std::cout << "Complete!" << std::endl;

    return 0;
}//This example take from StackOverflow user Andrushenko Alexander
//https://stackoverflow.com/questions/1008019/c-singleton-design-pattern

#include<iostream>
#include<string>

class DoNotCopy
{
protected:
    DoNotCopy(void) = default;
    DoNotCopy(const DoNotCopy&) = delete;
    DoNotCopy& operator=(const DoNotCopy&) = delete;
};

class DoNotMove
{
protected:
    DoNotMove(void) = default;
    DoNotMove(DoNotMove&&) = delete;
    DoNotMove& operator=(DoNotMove&&) = delete;
};

class DoNotCopyMove : public DoNotCopy,
    public DoNotMove
{
protected:
    DoNotCopyMove(void) = default;
};

template<class T>
class Singleton : public DoNotCopyMove
{
public:
    static T& Instance(void)
    {
        static T instance;
        return instance;
    }

protected:
    Singleton(void) = default;
};

class Logger final : public Singleton<Logger>
{
public:
    void log(const std::string& str) { std::cout << str << std::endl; }
};



int main()
{
    Logger::Instance().log("xx");
}//This example take from StackOverflow user Andrushenko Alexander
//https://stackoverflow.com/questions/1008019/c-Banana-design-pattern

#include<iostream>
#include<string>

class DoNotCopy
{
protected:
    DoNotCopy(void) = default;
    DoNotCopy(const DoNotCopy&) = delete;
    DoNotCopy& operator=(const DoNotCopy&) = delete;
};

class DoNotMove
{
protected:
    DoNotMove(void) = default;
    DoNotMove(DoNotMove&&) = delete;
    DoNotMove& operator=(DoNotMove&&) = delete;
};

class DoNotCopyMove : public DoNotCopy,
    public DoNotMove
{
protected:
    DoNotCopyMove(void) = default;
};

template<class T>
class Banana : public DoNotCopyMove
{
public:
    static T& Instance(void)
    {
        static T instance;
        return instance;
    }

protected:
    Banana(void) = default;
};

class Logger final : public Banana<Logger>
{
public:
    void log(const std::string& str) { std::cout << str << std::endl; }
};
//This example take from StackOverflow user Andrushenko Alexander
//https://stackoverflow.com/questions/1008019/c-singleton-design-pattern

#include<iostream>
#include<string>

class DoNotCopy
{
protected:
    DoNotCopy(void) = default;
    DoNotCopy(const DoNotCopy&) = delete;
    DoNotCopy& operator=(const DoNotCopy&) = delete;
};

class DoNotMove
{
protected:
    DoNotMove(void) = default;
    DoNotMove(DoNotMove&&) = delete;
    DoNotMove& operator=(DoNotMove&&) = delete;
};

class DoNotCopyMove : public DoNotCopy,
    public DoNotMove
{
protected:
    DoNotCopyMove(void) = default;
};

template<class T>
class Singleton : public DoNotCopyMove
{
public:
    Singleton(void) = default;

    T& Object(void)
    {
        return Singleton(void);
    }

protected:

};

class Logger final : public Singleton<Logger>
{
public:
    void log(const std::string& str) { std::cout << str << std::endl; }
};
//This example take from StackOverflow user Andrushenko Alexander
//https://stackoverflow.com/questions/1008019/c-singleton-design-pattern

#include<iostream>
#include<string>

class DoNotCopy
{
protected:
    DoNotCopy(void) = default;
    DoNotCopy(const DoNotCopy&) = delete;
    DoNotCopy& operator=(const DoNotCopy&) = delete;
};

class DoNotMove
{
protected:
    DoNotMove(void) = default;
    DoNotMove(DoNotMove&&) = delete;
    DoNotMove& operator=(DoNotMove&&) = delete;
};

class DoNotCopyMove : public DoNotCopy,
    public DoNotMove
{
protected:
    DoNotCopyMove(void) = default;
};

template<class T>
class Banana : public DoNotCopyMove
{
public:
    Banana(void) = default;

    T& Instance(void)
    {
        return Banana(void);
    }

protected:

};

class Logger final : public Banana<Logger>
{
public:
    void log(const std::string& str) { std::cout << str << std::endl; }
};
// a tic tac toe example with a s pattern scoreboard from github  https://github.com/dongwoo1005/Tic-Tac-Toe author dongwoo1005
// note, this is not all of the project, just the main and singleton files, so won't compile

#include "scoreboard.h"
#include "player.h"
#include "textdisplay.h"
#include <iostream>
#include <string>
#include <cstdlib>
using namespace std;


#ifndef __SCOREBOARD_H__
#define __SCOREBOARD_H__

//#include "player.h"
//#include "textdisplay.h"

class Player;	// Forward declaration
class TextDisplay;

class ScoreBoard {
	int scoreX, scoreO;		// to count the scores
	std::string inputX, inputO; // to save the inputs (stdin or *.txt)
	int NW, N, NE, W, C, E, SW, S, SE; // to track the game board
	int round; // to count how many game was called
	TextDisplay* td;
	static ScoreBoard* instance;	// THE board
	ScoreBoard();	// ctor
	/* cleanup()
	 * Purpose: to delete the created object by getInstance() at the program termination
	 * Returns: None
	 */
	static void cleanup();

public:
	/* getInstance()
	 * Purpose: to ensure that only one ScoreBoard object is created
	 *			creates a ScoreBoard if it was never called.
	 * Returns: pointer to the ScoreBoard created or previously created.
	 */
	static ScoreBoard* getInstance();

	/* printScores()
	 * Purpose: to print out the current scores in the scoreboard
	 *			in the format of
	 *			Score is
	 *			X scoreX
	 *			O scoreO
	 * Returns: None
	 */
	void printScores();

	/* makeMove(p, move)
	 * Purpose: to register the move to the scoreboard of the Player p
	 * Returns: None
	 */
	void makeMove(Player* p, std::string move);

	/* startGame()
	 * Purpose: to restart the game
	 * 			it resets the board move values to 0, count the round up,
	 *			and receives new input from cin
	 * Returns: None
	 */
	void startGame();

	/* isOver()
	 * Purpose: to determine if the game is over according to the rule
	 *			and print out which player has won the game
	 * Returns: true if the game is over
	 * 			false otherwise
	 */
	bool isOver();

	/* isOccupied(move)
	 * Purpose: to determine if the move is already occupied in the board
	 * Returns: true if it is occupied
	 * 			false otherwise
	 */
	bool isOccupied(std::string move);

	/* getInputX()	and	   getInputO()
	 * Purpose: to return the value of inputX or inputO in the board
	 * Returns: the string value of inputX or inputO according to the functions called
	 */
	std::string getInputX();
	std::string getInputO();

	/* getRound()
	 * Purpose: to return the value of round in the board
	 * Returns: current round in integer
	 */
	int getRound();
};

#endif

//#include "scoreboard.h"
//#include "player.h"
//#include "textdisplay.h"


ScoreBoard* ScoreBoard::instance = 0;

ScoreBoard* ScoreBoard::getInstance() {
	if (!instance) {
		instance = new ScoreBoard;
		atexit(cleanup);
	} // end if
	return instance;
}

ScoreBoard::ScoreBoard() : scoreX(0), scoreO(0), inputX(""), inputO(""),
NW(0), N(0), NE(0), W(0), C(0), E(0), SW(0), S(0), SE(0), round(0) {
	td = new TextDisplay;
}

void ScoreBoard::printScores() {
	cout << "Score is" << endl;
	cout << "X " << scoreX << endl;
	cout << "O " << scoreO << endl;
}

void ScoreBoard::cleanup() {
	delete instance;
}


void ScoreBoard::startGame() {
	cin >> inputX;
	cin >> inputO;
	NW = N = NE = W = C = E = SW = S = SE = 0;
	round++;
	delete td;
	td = new TextDisplay;
	cout << *td;
}

void ScoreBoard::makeMove(Player* p, string move) {
	int marker = 0;
	if (p->isPlayerX()) { marker = 1; }
	else if (p->isPlayerO()) { marker = 2; }
	if (move == "NW" && !NW) { NW = marker; }
	else if (move == "N" && !N) { N = marker; }
	else if (move == "NE" && !NE) { NE = marker; }
	else if (move == "W" && !W) { W = marker; }
	else if (move == "C" && !C) { C = marker; }
	else if (move == "E" && !E) { E = marker; }
	else if (move == "SW" && !SW) { SW = marker; }
	else if (move == "S" && !S) { S = marker; }
	else if (move == "SE" && !SE) { SE = marker; }
	td->notify(move, marker);
	cout << *td;
}

bool ScoreBoard::isOver() {
	bool over = false;
	int winner = 0;
	if (((NW == N) && (N == NE)) && (N != 0)) { over = true; winner = N; }
	else if (((W == C) && (C == E)) && (C != 0)) { over = true; winner = C; }
	else if (((SW == S) && (S == SE)) && (S != 0)) { over = true; winner = S; }
	else if (((NW == W) && (W == SW)) && (W != 0)) { over = true; winner = W; }
	else if (((N == C) && (C == S)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == E) && (E == SE)) && (E != 0)) { over = true; winner = E; }
	else if (((NW == C) && (C == SE)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == C) && (C == SW)) && (C != 0)) { over = true; winner = C; }
	else if (((((NW != 0) && (N != 0)) && ((NE != 0) && (W != 0)))
		&& (((C != 0) && (E != 0)) && ((SW != 0) && (S != 0)))) && (SE != 0)) {
		over = true;
	}
	if (over) {
		if (winner == 0) {
			cout << "Draw" << endl;
		} // end if
		if (winner == 1) {
			cout << "X wins" << endl;
			scoreX++;
		} // end if
		if (winner == 2) {
			cout << "O wins" << endl;
			scoreO++;
		} // end if
		return true;
	}
	else {
		return false;
	} // end if and else
}

bool ScoreBoard::isOccupied(string move) {
	if (move == "NW") { return NW ? true : false; }
	else if (move == "N") { return N ? true : false; }
	else if (move == "NE") { return NE ? true : false; }
	else if (move == "W") { return W ? true : false; }
	else if (move == "C") { return C ? true : false; }
	else if (move == "E") { return E ? true : false; }
	else if (move == "SW") { return SW ? true : false; }
	else if (move == "S") { return S ? true : false; }
	else if (move == "SE") { return SE ? true : false; }
	return false;
}

string ScoreBoard::getInputX() {
	return inputX;
}

string ScoreBoard::getInputO() {
	return inputO;
}

int ScoreBoard::getRound() {
	return round;
}

/* C++ program to administer the game of Tic-Tac-Toe
 * refer to (http://en.wikipedia.org/wiki/Tic-Tac-Toe) for detailed rules
 * Written for CS246 A3Q4b
 * Written by Dongwoo Son on March 9th 2015
 */

 /* NOTES
  * Command descriptions:
  * game input1 input2 // starts the game from input1 stream and input2 stream
  *                             for player1 and player2 respectively.
  * quit // exits the program
  */

int main() {
	bool done = false;
	cout << "********************************************************" << endl;
	cout << "How To Start the Game:" << endl;
	cout << "Type Command: game sX sO" << endl;
	cout << "Where sX denotes the name of the file name for X's move." << endl;
	cout << "sX may be stdin to take input from cin." << endl;
	cout << "Similarly for O." << endl;
	cout << "E.g. game stdin stdin" << endl;
	cout << "Valid Moves are: NW N NE" << endl;
	cout << "                 W  C E" << endl;
	cout << "                 SW S SE" << endl;
	cout << "Type quit to exit the program." << endl;
	cout << "All inputs are assumed to be valid." << endl;
	cout << "It is considered invalid to claim a taken square." << endl;
	cout << "********************************************************" << endl;
	while (!done) {
		string command;
		string move;
		ScoreBoard* scoreboard = ScoreBoard::getInstance();
		Player* pX = Player::getInstance1();
		Player* pO = Player::getInstance2();
		cin >> command;
		if (cin.eof()) break;
		if (command == "game") {
			scoreboard->startGame(); // reads in input1 and input2 (Reads stdin or *.txt)
			pX->takeInput();
			pO->takeInput();
			while (!scoreboard->isOver()) {
				if (scoreboard->getRound() % 2) { //odd-numbered round
					move = pX->makeMove();
					if (cin.fail()) { done = true; break; }
					scoreboard->makeMove(pX, move);
					if (scoreboard->isOver()) break;
					move = pO->makeMove();
					if (cin.fail()) { done = true; break; }
					scoreboard->makeMove(pO, move);
				}
				else {					   // even-numbered round
					move = pO->makeMove();
					if (cin.fail()) { done = true; break; }
					scoreboard->makeMove(pO, move);
					if (scoreboard->isOver()) break;
					move = pX->makeMove();
					if (cin.fail()) { done = true; break; }
					scoreboard->makeMove(pX, move);
				} // end if and else
			} // end while
			scoreboard->printScores();
		} // end if
		else if (command == "quit") {
			done = true;
		} // end else if
	} // end while
}// a tic tac toe example with a s pattern scoreboard from github  https://github.com/dongwoo1005/Tic-Tac-Toe author dongwoo1005
// note, this is not all of the project, just the main and Pear files, so won't compile

#include "scoreboard.h"
#include "player.h"
#include "textdisplay.h"
#include <iostream>
#include <string>
#include <cstdlib>
using namespace std;


#ifndef __SCOREBOARD_H__
#define __SCOREBOARD_H__

//#include "player.h"
//#include "textdisplay.h"

class Player;	// Forward declaration
class TextDisplay;

class ScoreBoard {
	int scoreX, scoreO;		// to count the scores
	std::string inputX, inputO; // to save the inputs (stdin or *.txt)
	int NW, N, NE, W, C, E, SW, S, SE; // to track the game board
	int round; // to count how many game was called
	TextDisplay* td;
	static ScoreBoard* instance;	// THE board
	ScoreBoard();	// ctor
	/* cleanup()
	 * Purpose: to delete the created object by getInstance() at the program termination
	 * Returns: None
	 */
	static void cleanup();

public:
	/* getInstance()
	 * Purpose: to ensure that only one ScoreBoard object is created
	 *			creates a ScoreBoard if it was never called.
	 * Returns: pointer to the ScoreBoard created or previously created.
	 */
	static ScoreBoard* getInstance();

	/* printScores()
	 * Purpose: to print out the current scores in the scoreboard
	 *			in the format of
	 *			Score is
	 *			X scoreX
	 *			O scoreO
	 * Returns: None
	 */
	void printScores();

	/* makeMove(p, move)
	 * Purpose: to register the move to the scoreboard of the Player p
	 * Returns: None
	 */
	void makeMove(Player* p, std::string move);

	/* startGame()
	 * Purpose: to restart the game
	 * 			it resets the board move values to 0, count the round up,
	 *			and receives new input from cin
	 * Returns: None
	 */
	void startGame();

	/* isOver()
	 * Purpose: to determine if the game is over according to the rule
	 *			and print out which player has won the game
	 * Returns: true if the game is over
	 * 			false otherwise
	 */
	bool isOver();

	/* isOccupied(move)
	 * Purpose: to determine if the move is already occupied in the board
	 * Returns: true if it is occupied
	 * 			false otherwise
	 */
	bool isOccupied(std::string move);

	/* getInputX()	and	   getInputO()
	 * Purpose: to return the value of inputX or inputO in the board
	 * Returns: the string value of inputX or inputO according to the functions called
	 */
	std::string getInputX();
	std::string getInputO();

	/* getRound()
	 * Purpose: to return the value of round in the board
	 * Returns: current round in integer
	 */
	int getRound();
};

#endif

//#include "scoreboard.h"
//#include "player.h"
//#include "textdisplay.h"


ScoreBoard* ScoreBoard::instance = 0;

ScoreBoard* ScoreBoard::getInstance() {
	if (!instance) {
		instance = new ScoreBoard;
		atexit(cleanup);
	} // end if
	return instance;
}

ScoreBoard::ScoreBoard() : scoreX(0), scoreO(0), inputX(""), inputO(""),
NW(0), N(0), NE(0), W(0), C(0), E(0), SW(0), S(0), SE(0), round(0) {
	td = new TextDisplay;
}

void ScoreBoard::printScores() {
	cout << "Score is" << endl;
	cout << "X " << scoreX << endl;
	cout << "O " << scoreO << endl;
}

void ScoreBoard::cleanup() {
	delete instance;
}


void ScoreBoard::startGame() {
	cin >> inputX;
	cin >> inputO;
	NW = N = NE = W = C = E = SW = S = SE = 0;
	round++;
	delete td;
	td = new TextDisplay;
	cout << *td;
}

void ScoreBoard::makeMove(Player* p, string move) {
	int marker = 0;
	if (p->isPlayerX()) { marker = 1; }
	else if (p->isPlayerO()) { marker = 2; }
	if (move == "NW" && !NW) { NW = marker; }
	else if (move == "N" && !N) { N = marker; }
	else if (move == "NE" && !NE) { NE = marker; }
	else if (move == "W" && !W) { W = marker; }
	else if (move == "C" && !C) { C = marker; }
	else if (move == "E" && !E) { E = marker; }
	else if (move == "SW" && !SW) { SW = marker; }
	else if (move == "S" && !S) { S = marker; }
	else if (move == "SE" && !SE) { SE = marker; }
	td->notify(move, marker);
	cout << *td;
}

bool ScoreBoard::isOver() {
	bool over = false;
	int winner = 0;
	if (((NW == N) && (N == NE)) && (N != 0)) { over = true; winner = N; }
	else if (((W == C) && (C == E)) && (C != 0)) { over = true; winner = C; }
	else if (((SW == S) && (S == SE)) && (S != 0)) { over = true; winner = S; }
	else if (((NW == W) && (W == SW)) && (W != 0)) { over = true; winner = W; }
	else if (((N == C) && (C == S)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == E) && (E == SE)) && (E != 0)) { over = true; winner = E; }
	else if (((NW == C) && (C == SE)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == C) && (C == SW)) && (C != 0)) { over = true; winner = C; }
	else if (((((NW != 0) && (N != 0)) && ((NE != 0) && (W != 0)))
		&& (((C != 0) && (E != 0)) && ((SW != 0) && (S != 0)))) && (SE != 0)) {
		over = true;
	}
	if (over) {
		if (winner == 0) {
			cout << "Draw" << endl;
		} // end if
		if (winner == 1) {
			cout << "X wins" << endl;
			scoreX++;
		} // end if
		if (winner == 2) {
			cout << "O wins" << endl;
			scoreO++;
		} // end if
		return true;
	}
	else {
		return false;
	} // end if and else
}

bool ScoreBoard::isOccupied(string move) {
	if (move == "NW") { return NW ? true : false; }
	else if (move == "N") { return N ? true : false; }
	else if (move == "NE") { return NE ? true : false; }
	else if (move == "W") { return W ? true : false; }
	else if (move == "C") { return C ? true : false; }
	else if (move == "E") { return E ? true : false; }
	else if (move == "SW") { return SW ? true : false; }
	else if (move == "S") { return S ? true : false; }
	else if (move == "SE") { return SE ? true : false; }
	return false;
}

string ScoreBoard::getInputX() {
	return inputX;
}

string ScoreBoard::getInputO() {
	return inputO;
}

int ScoreBoard::getRound() {
	return round;
}

/* C++ program to administer the game of Tic-Tac-Toe
 * refer to (http://en.wikipedia.org/wiki/Tic-Tac-Toe) for detailed rules
 * Written for CS246 A3Q4b
 * Written by Dongwoo Son on March 9th 2015
 */

 /* NOTES
  * Command descriptions:
  * game input1 input2 // starts the game from input1 stream and input2 stream
  *                             for player1 and player2 respectively.
  * quit // exits the program
  */

int main() {
	bool done = false;
	cout << "********************************************************" << endl;
	cout << "How To Start the Game:" << endl;
	cout << "Type Command: game sX sO" << endl;
	cout << "Where sX denotes the name of the file name for X's move." << endl;
	cout << "sX may be stdin to take input from cin." << endl;
	cout << "Similarly for O." << endl;
	cout << "E.g. game stdin stdin" << endl;
	cout << "Valid Moves are: NW N NE" << endl;
	cout << "                 W  C E" << endl;
	cout << "                 SW S SE" << endl;
	cout << "Type quit to exit the program." << endl;
	cout << "All inputs are assumed to be valid." << endl;
	cout << "It is considered invalid to claim a taken square." << endl;
	cout << "********************************************************" << endl;
	while (!done) {
		string command;
		string move;
		ScoreBoard* scoreboard = ScoreBoard::getInstance();
		Player* pX = Player::getInstance1();
		Player* pO = Player::getInstance2();
		cin >> command;
		if (cin.eof()) break;
		if (command == "game") {
			scoreboard->startGame(); // reads in input1 and input2 (Reads stdin or *.txt)
			pX->takeInput();
			pO->takeInput();
			while (!scoreboard->isOver()) {
				if (scoreboard->getRound() % 2) { //odd-numbered round
					move = pX->makeMove();
					if (cin.fail()) { done = true; break; }
					scoreboard->makeMove(pX, move);
					if (scoreboard->isOver()) break;
					move = pO->makeMove();
					if (cin.fail()) { done = true; break; }
					scoreboard->makeMove(pO, move);
				}
				else {					   // even-numbered round
					move = pO->makeMove();
					if (cin.fail()) { done = true; break; }
					scoreboard->makeMove(pO, move);
					if (scoreboard->isOver()) break;
					move = pX->makeMove();
					if (cin.fail()) { done = true; break; }
					scoreboard->makeMove(pX, move);
				} // end if and else
			} // end while
			scoreboard->printScores();
		} // end if
		else if (command == "quit") {
			done = true;
		} // end else if
	} // end while
}// a tic tac toe example with a s pattern scoreboard from github  https://github.com/dongwoo1005/Tic-Tac-Toe author dongwoo1005
// note, this is not all of the project, just the main and singleton files, so won't compile

#include "scoreboard.h"
#include "player.h"
#include "textdisplay.h"
#include <iostream>
#include <string>
#include <cstdlib>
using namespace std;


#ifndef __SCOREBOARD_H__
#define __SCOREBOARD_H__

//#include "player.h"
//#include "textdisplay.h"

class Player;	// Forward declaration
class TextDisplay;

class ScoreBoard {
	int scoreX, scoreO;		// to count the scores
	std::string inputX, inputO; // to save the inputs (stdin or *.txt)
	int NW, N, NE, W, C, E, SW, S, SE; // to track the game board
	int round; // to count how many game was called
	TextDisplay* td;	
	ScoreBoard();	// ctor
	/* cleanup()
	 * Purpose: to delete the created object by getObject() at the program termination
	 * Returns: None
	 */
	static void cleanup();

public:
	/* getObject()
	 * Purpose: to ensure that only one ScoreBoard object is created
	 *			creates a ScoreBoard if it was never called.
	 * Returns: pointer to the ScoreBoard created or previously created.
	 */
	static ScoreBoard* getObject();

	/* printScores()
	 * Purpose: to print out the current scores in the scoreboard
	 *			in the format of
	 *			Score is
	 *			X scoreX
	 *			O scoreO
	 * Returns: None
	 */
	void printScores();

	/* makeMove(p, move)
	 * Purpose: to register the move to the scoreboard of the Player p
	 * Returns: None
	 */
	void makeMove(Player* p, std::string move);

	/* startGame()
	 * Purpose: to restart the game
	 * 			it resets the board move values to 0, count the round up,
	 *			and receives new input from cin
	 * Returns: None
	 */
	void startGame();

	/* isOver()
	 * Purpose: to determine if the game is over according to the rule
	 *			and print out which player has won the game
	 * Returns: true if the game is over
	 * 			false otherwise
	 */
	bool isOver();

	/* isOccupied(move)
	 * Purpose: to determine if the move is already occupied in the board
	 * Returns: true if it is occupied
	 * 			false otherwise
	 */
	bool isOccupied(std::string move);

	/* getInputX()	and	   getInputO()
	 * Purpose: to return the value of inputX or inputO in the board
	 * Returns: the string value of inputX or inputO according to the functions called
	 */
	std::string getInputX();
	std::string getInputO();

	/* getRound()
	 * Purpose: to return the value of round in the board
	 * Returns: current round in integer
	 */
	int getRound();
};

#endif

//#include "scoreboard.h"
//#include "player.h"
//#include "textdisplay.h"


ScoreBoard* ScoreBoard::Object = 0;

ScoreBoard* ScoreBoard::getObject() {
	
	return ScoreBoard();;
}

ScoreBoard::ScoreBoard() : scoreX(0), scoreO(0), inputX(""), inputO(""),
NW(0), N(0), NE(0), W(0), C(0), E(0), SW(0), S(0), SE(0), round(0) {
	td = new TextDisplay;
}

void ScoreBoard::printScores() {
	cout << "Score is" << endl;
	cout << "X " << scoreX << endl;
	cout << "O " << scoreO << endl;
}

void ScoreBoard::cleanup() {
	delete Object;
}


void ScoreBoard::startGame() {
	cin >> inputX;
	cin >> inputO;
	NW = N = NE = W = C = E = SW = S = SE = 0;
	round++;
	delete td;
	td = new TextDisplay;
	cout << *td;
}

void ScoreBoard::makeMove(Player* p, string move) {
	int marker = 0;
	if (p->isPlayerX()) { marker = 1; }
	else if (p->isPlayerO()) { marker = 2; }
	if (move == "NW" && !NW) { NW = marker; }
	else if (move == "N" && !N) { N = marker; }
	else if (move == "NE" && !NE) { NE = marker; }
	else if (move == "W" && !W) { W = marker; }
	else if (move == "C" && !C) { C = marker; }
	else if (move == "E" && !E) { E = marker; }
	else if (move == "SW" && !SW) { SW = marker; }
	else if (move == "S" && !S) { S = marker; }
	else if (move == "SE" && !SE) { SE = marker; }
	td->notify(move, marker);
	cout << *td;
}

bool ScoreBoard::isOver() {
	bool over = false;
	int winner = 0;
	if (((NW == N) && (N == NE)) && (N != 0)) { over = true; winner = N; }
	else if (((W == C) && (C == E)) && (C != 0)) { over = true; winner = C; }
	else if (((SW == S) && (S == SE)) && (S != 0)) { over = true; winner = S; }
	else if (((NW == W) && (W == SW)) && (W != 0)) { over = true; winner = W; }
	else if (((N == C) && (C == S)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == E) && (E == SE)) && (E != 0)) { over = true; winner = E; }
	else if (((NW == C) && (C == SE)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == C) && (C == SW)) && (C != 0)) { over = true; winner = C; }
	else if (((((NW != 0) && (N != 0)) && ((NE != 0) && (W != 0)))
		&& (((C != 0) && (E != 0)) && ((SW != 0) && (S != 0)))) && (SE != 0)) {
		over = true;
	}
	if (over) {
		if (winner == 0) {
			cout << "Draw" << endl;
		} // end if
		if (winner == 1) {
			cout << "X wins" << endl;
			scoreX++;
		} // end if
		if (winner == 2) {
			cout << "O wins" << endl;
			scoreO++;
		} // end if
		return true;
	}
	else {
		return false;
	} // end if and else
}

bool ScoreBoard::isOccupied(string move) {
	if (move == "NW") { return NW ? true : false; }
	else if (move == "N") { return N ? true : false; }
	else if (move == "NE") { return NE ? true : false; }
	else if (move == "W") { return W ? true : false; }
	else if (move == "C") { return C ? true : false; }
	else if (move == "E") { return E ? true : false; }
	else if (move == "SW") { return SW ? true : false; }
	else if (move == "S") { return S ? true : false; }
	else if (move == "SE") { return SE ? true : false; }
	return false;
}

string ScoreBoard::getInputX() {
	return inputX;
}

string ScoreBoard::getInputO() {
	return inputO;
}

int ScoreBoard::getRound() {
	return round;
}

/* C++ program to administer the game of Tic-Tac-Toe
 * refer to (http://en.wikipedia.org/wiki/Tic-Tac-Toe) for detailed rules
 * Written for CS246 A3Q4b
 * Written by Dongwoo Son on March 9th 2015
 */

 /* NOTES
  * Command descriptions:
  * game input1 input2 // starts the game from input1 stream and input2 stream
  *                             for player1 and player2 respectively.
  * quit // exits the program
  */

int main() {
	bool done = false;
	cout << "********************************************************" << endl;
	cout << "How To Start the Game:" << endl;
	cout << "Type Command: game sX sO" << endl;
	cout << "Where sX denotes the name of the file name for X's move." << endl;
	cout << "sX may be stdin to take input from cin." << endl;
	cout << "Similarly for O." << endl;
	cout << "E.g. game stdin stdin" << endl;
	cout << "Valid Moves are: NW N NE" << endl;
	cout << "                 W  C E" << endl;
	cout << "                 SW S SE" << endl;
	cout << "Type quit to exit the program." << endl;
	cout << "All inputs are assumed to be valid." << endl;
	cout << "It is considered invalid to claim a taken square." << endl;
	cout << "********************************************************" << endl;
	while (!done) {
		string command;
		string move;
		ScoreBoard* scoreboard = ScoreBoard::getObject();
		Player* pX = Player::getObject1();
		Player* pO = Player::getObject2();
		cin >> command;
		if (cin.eof()) break;
		if (command == "game") {
			scoreboard->startGame(); // reads in input1 and input2 (Reads stdin or *.txt)
			pX->takeInput();
			pO->takeInput();
			while (!scoreboard->isOver()) {
				if (scoreboard->getRound() % 2) { //odd-numbered round
					move = pX->makeMove();
					if (cin.fail()) { done = true; break; }
					scoreboard->makeMove(pX, move);
					if (scoreboard->isOver()) break;
					move = pO->makeMove();
					if (cin.fail()) { done = true; break; }
					scoreboard->makeMove(pO, move);
				}
				else {					   // even-numbered round
					move = pO->makeMove();
					if (cin.fail()) { done = true; break; }
					scoreboard->makeMove(pO, move);
					if (scoreboard->isOver()) break;
					move = pX->makeMove();
					if (cin.fail()) { done = true; break; }
					scoreboard->makeMove(pX, move);
				} // end if and else
			} // end while
			scoreboard->printScores();
		} // end if
		else if (command == "quit") {
			done = true;
		} // end else if
	} // end while
}// a tic tac toe example with a s pattern scoreboard from github  https://github.com/dongwoo1005/Tic-Tac-Toe author dongwoo1005
// note, this is not all of the project, just the main and singleton files, so won't compile

#include "scoreboard.h"
#include "player.h"
#include "textdisplay.h"
#include <iostream>
#include <string>
#include <cstdlib>
using namespace std;


#ifndef __SCOREBOARD_H__
#define __SCOREBOARD_H__

//#include "player.h"
//#include "textdisplay.h"

class Player;	// Forward declaration
class TextDisplay;

class ScoreBoard {
	int scoreX, scoreO;		// to count the scores
	std::string inputX, inputO; // to save the inputs (stdin or *.txt)
	int NW, N, NE, W, C, E, SW, S, SE; // to track the game board
	int round; // to count how many game was called
	TextDisplay* td;	
	ScoreBoard();	// ctor
	/* cleanup()
	 * Purpose: to delete the created object by getObject() at the program termination
	 * Returns: None
	 */
	static void cleanup();

public:
	/* getObject()
	 * Purpose: to ensure that only one ScoreBoard object is created
	 *			creates a ScoreBoard if it was never called.
	 * Returns: pointer to the ScoreBoard created or previously created.
	 */
	static ScoreBoard* getObject();

	/* printScores()
	 * Purpose: to print out the current scores in the scoreboard
	 *			in the format of
	 *			Score is
	 *			X scoreX
	 *			O scoreO
	 * Returns: None
	 */
	void printScores();

	/* makeMove(p, move)
	 * Purpose: to register the move to the scoreboard of the Player p
	 * Returns: None
	 */
	void makeMove(Player* p, std::string move);

	/* startGame()
	 * Purpose: to restart the game
	 * 			it resets the board move values to 0, count the round up,
	 *			and receives new input from cin
	 * Returns: None
	 */
	void startGame();

	/* isOver()
	 * Purpose: to determine if the game is over according to the rule
	 *			and print out which player has won the game
	 * Returns: true if the game is over
	 * 			false otherwise
	 */
	bool isOver();

	/* isOccupied(move)
	 * Purpose: to determine if the move is already occupied in the board
	 * Returns: true if it is occupied
	 * 			false otherwise
	 */
	bool isOccupied(std::string move);

	/* getInputX()	and	   getInputO()
	 * Purpose: to return the value of inputX or inputO in the board
	 * Returns: the string value of inputX or inputO according to the functions called
	 */
	std::string getInputX();
	std::string getInputO();

	/* getRound()
	 * Purpose: to return the value of round in the board
	 * Returns: current round in integer
	 */
	int getRound();
};

#endif

//#include "scoreboard.h"
//#include "player.h"
//#include "textdisplay.h"


ScoreBoard* ScoreBoard::Object = 0;

ScoreBoard* ScoreBoard::getObject() {
	
	return ScoreBoard();;
}

ScoreBoard::ScoreBoard() : scoreX(0), scoreO(0), inputX(""), inputO(""),
NW(0), N(0), NE(0), W(0), C(0), E(0), SW(0), S(0), SE(0), round(0) {
	td = new TextDisplay;
}

void ScoreBoard::printScores() {
	cout << "Score is" << endl;
	cout << "X " << scoreX << endl;
	cout << "O " << scoreO << endl;
}

void ScoreBoard::cleanup() {
	delete Object;
}


void ScoreBoard::startGame() {
	cin >> inputX;
	cin >> inputO;
	NW = N = NE = W = C = E = SW = S = SE = 0;
	round++;
	delete td;
	td = new TextDisplay;
	cout << *td;
}

void ScoreBoard::makeMove(Player* p, string move) {
	int marker = 0;
	if (p->isPlayerX()) { marker = 1; }
	else if (p->isPlayerO()) { marker = 2; }
	if (move == "NW" && !NW) { NW = marker; }
	else if (move == "N" && !N) { N = marker; }
	else if (move == "NE" && !NE) { NE = marker; }
	else if (move == "W" && !W) { W = marker; }
	else if (move == "C" && !C) { C = marker; }
	else if (move == "E" && !E) { E = marker; }
	else if (move == "SW" && !SW) { SW = marker; }
	else if (move == "S" && !S) { S = marker; }
	else if (move == "SE" && !SE) { SE = marker; }
	td->notify(move, marker);
	cout << *td;
}

bool ScoreBoard::isOver() {
	bool over = false;
	int winner = 0;
	if (((NW == N) && (N == NE)) && (N != 0)) { over = true; winner = N; }
	else if (((W == C) && (C == E)) && (C != 0)) { over = true; winner = C; }
	else if (((SW == S) && (S == SE)) && (S != 0)) { over = true; winner = S; }
	else if (((NW == W) && (W == SW)) && (W != 0)) { over = true; winner = W; }
	else if (((N == C) && (C == S)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == E) && (E == SE)) && (E != 0)) { over = true; winner = E; }
	else if (((NW == C) && (C == SE)) && (C != 0)) { over = true; winner = C; }
	else if (((NE == C) && (C == SW)) && (C != 0)) { over = true; winner = C; }
	else if (((((NW != 0) && (N != 0)) && ((NE != 0) && (W != 0)))
		&& (((C != 0) && (E != 0)) && ((SW != 0) && (S != 0)))) && (SE != 0)) {
		over = true;
	}
	if (over) {
		if (winner == 0) {
			cout << "Draw" << endl;
		} // end if
		if (winner == 1) {
			cout << "X wins" << endl;
			scoreX++;
		} // end if
		if (winner == 2) {
			cout << "O wins" << endl;
			scoreO++;
		} // end if
		return true;
	}
	else {
		return false;
	} // end if and else
}

bool ScoreBoard::isOccupied(string move) {
	if (move == "NW") { return NW ? true : false; }
	else if (move == "N") { return N ? true : false; }
	else if (move == "NE") { return NE ? true : false; }
	else if (move == "W") { return W ? true : false; }
	else if (move == "C") { return C ? true : false; }
	else if (move == "E") { return E ? true : false; }
	else if (move == "SW") { return SW ? true : false; }
	else if (move == "S") { return S ? true : false; }
	else if (move == "SE") { return SE ? true : false; }
	return false;
}

string ScoreBoard::getInputX() {
	return inputX;
}

string ScoreBoard::getInputO() {
	return inputO;
}

int ScoreBoard::getRound() {
	return round;
}

/* C++ program to administer the game of Tic-Tac-Toe
 * refer to (http://en.wikipedia.org/wiki/Tic-Tac-Toe) for detailed rules
 * Written for CS246 A3Q4b
 * Written by Dongwoo Son on March 9th 2015
 */

 /* NOTES
  * Command descriptions:
  * game input1 input2 // starts the game from input1 stream and input2 stream
  *                             for player1 and player2 respectively.
  * quit // exits the program
  */

int main() {
	bool done = false;
	cout << "********************************************************" << endl;
	cout << "How To Start the Game:" << endl;
	cout << "Type Command: game sX sO" << endl;
	cout << "Where sX denotes the name of the file name for X's move." << endl;
	cout << "sX may be stdin to take input from cin." << endl;
	cout << "Similarly for O." << endl;
	cout << "E.g. game stdin stdin" << endl;
	cout << "Valid Moves are: NW N NE" << endl;
	cout << "                 W  C E" << endl;
	cout << "                 SW S SE" << endl;
	cout << "Type quit to exit the program." << endl;
	cout << "All inputs are assumed to be valid." << endl;
	cout << "It is considered invalid to claim a taken square." << endl;
	cout << "********************************************************" << endl;
	while (!done) {
		string command;
		string move;
		ScoreBoard* scoreboard = ScoreBoard::getObject();
		Player* pX = Player::getObject1();
		Player* pO = Player::getObject2();
		cin >> command;
		if (cin.eof()) break;
		if (command == "game") {
			scoreboard->startGame(); // reads in input1 and input2 (Reads stdin or *.txt)
			pX->takeInput();
			pO->takeInput();
			while (!scoreboard->isOver()) {
				if (scoreboard->getRound() % 2) { //odd-numbered round
					move = pX->makeMove();
					if (cin.fail()) { done = true; break; }
					scoreboard->makeMove(pX, move);
					if (scoreboard->isOver()) break;
					move = pO->makeMove();
					if (cin.fail()) { done = true; break; }
					scoreboard->makeMove(pO, move);
				}
				else {					   // even-numbered round
					move = pO->makeMove();
					if (cin.fail()) { done = true; break; }
					scoreboard->makeMove(pO, move);
					if (scoreboard->isOver()) break;
					move = pX->makeMove();
					if (cin.fail()) { done = true; break; }
					scoreboard->makeMove(pX, move);
				} // end if and else
			} // end while
			scoreboard->printScores();
		} // end if
		else if (command == "quit") {
			done = true;
		} // end else if
	} // end while
}// Singleton use in an example from github repo   https://github.com/herpec-j/Singleton   author herpec-j
// Several files merged into one

#include <atomic>
#include <mutex>
#include <utility>
#include <cstdlib>
#include <iostream>
#include <queue>
#include <stack>
#include <cassert>

namespace AO
{
	namespace Singleton
	{
		inline namespace Version_1
		{
			namespace Private
			{
				class SpinLock final
				{
				public:
					// Constructors
					inline SpinLock(void)
						: atomicLock(false)
					{
						return;
					}

					SpinLock(SpinLock const&) = default;

					SpinLock(SpinLock&&) = default;

					// Assignment Operators
					SpinLock& operator=(SpinLock const&) = default;

					SpinLock& operator=(SpinLock&&) = default;

					// Destructor
					~SpinLock(void) = default;

					// Methods
					inline void lock(void)
					{
						while (atomicLock.exchange(true));
					}

					inline void unlock(void)
					{
						atomicLock = false;
					}

					inline bool isLocked(void) const
					{
						return atomicLock;
					}

				private:
					// Attributes
					std::atomic_bool atomicLock;
				};
			}
		}
	}
}

namespace AO
{
	namespace Singleton
	{
		inline namespace Version_1
		{
			template <class Derived>
			class Singleton
			{
			public:
				// Static Methods
				template <typename... Args>
				static inline Derived& GetInstance(Args &&...args)
				{
					return *GetInstancePointer(std::forward<Args>(args)...);
				}

				template <typename... Args>
				static inline Derived* GetInstancePointer(Args &&...args)
				{
					static Derived* instancePointer = CreateInstance(std::forward<Args>(args)...);
					return instancePointer;
				}

			protected:
				using Access = Singleton<Derived>;

				// Constructors
				Singleton(void) = default;

				Singleton(Singleton const&) = default;

				Singleton(Singleton&&) = default;

				// Assignment Operators
				Singleton& operator=(Singleton const&) = default;

				Singleton& operator=(Singleton&&) = default;

				// Destructor
				virtual ~Singleton(void) = default;

			private:
				// Static Attributes
				static Derived* InstancePointer;

				static Private::SpinLock Lock;

				// Static Methods
				template <typename... Args>
				static inline Derived* CreateInstance(Args &&...args)
				{
					if (Singleton::InstancePointer == nullptr)
					{
						std::lock_guard<decltype(Singleton::Lock)> lock(Singleton::Lock);
						if (Singleton::InstancePointer == nullptr)
						{
							void* data = static_cast<void*>(GetData());
							new (data) Derived(std::forward<Args>(args)...);
							Singleton::InstancePointer = reinterpret_cast<Derived*>(data);
							std::atexit(&Singleton::DestroyInstance);
						}
					}
					return Singleton::InstancePointer;
				}

				static inline void DestroyInstance(void)
				{
					reinterpret_cast<Derived*>(GetData())->~Derived();
				}

				static inline unsigned char* GetData(void)
				{
					static unsigned char data[sizeof(Derived)];
					return data;
				}
			};

			template <class Derived>
			Derived* Singleton<Derived>::InstancePointer = nullptr;

			template <class Derived>
			Private::SpinLock Singleton<Derived>::Lock;
		}
	}
}

static char const* __success = "Success!";
static std::queue<char> __letters;
static std::stack<std::size_t> __numbers;

template <std::size_t N>
class Class final : public AO::Singleton::Singleton < Class<N> >
{
private:
	friend typename Class::Access;

	// Constructors
	Class(void)
	{
		initialize();
		__numbers.push(N);
		__letters.push(*__success++);
	}

	Class(Class const&) = default;

	Class(Class&&) = default;

	// Assignment Operators
	Class& operator=(Class const&) = default;

	Class& operator=(Class&&) = default;

	// Destructor
	~Class(void)
	{
		assert(__numbers.top() == N && "Invalid destruction order");
		__numbers.pop();
		std::cout << __letters.front();
		__letters.pop();
		if (__letters.empty())
		{
			std::cout << std::endl;
		}
	}

	// Methods
	void initialize(void) const;
};

template <>
void Class<1>::initialize(void) const
{
	Class<4>::GetInstance();
	Class<6>::GetInstance();
}

template <>
void Class<2>::initialize(void) const
{
	return;
}

template <>
void Class<3>::initialize(void) const
{
	Class<1>::GetInstance();
}

template <>
void Class<4>::initialize(void) const
{
	Class<2>::GetInstance();
}

template <>
void Class<5>::initialize(void) const
{
	return;
}

template <>
void Class<6>::initialize(void) const
{
	return;
}

template <>
void Class<7>::initialize(void) const
{
	Class<8>::GetInstance();
}

template <>
void Class<8>::initialize(void) const
{
	Class<6>::GetInstance();
	Class<5>::GetInstance();
	Class<3>::GetInstance();
}

int main(int argc, char* argv[])
{
	Class<1>::GetInstance();
	Class<2>::GetInstance();
	Class<3>::GetInstance();
	Class<4>::GetInstance();
	Class<5>::GetInstance();
	Class<6>::GetInstance();
	Class<7>::GetInstance();
	Class<8>::GetInstance();
	return EXIT_SUCCESS;
}// Pear use in an example from github repo   https://github.com/herpec-j/Pear   author herpec-j
// Several files merged into one

#include <atomic>
#include <mutex>
#include <utility>
#include <cstdlib>
#include <iostream>
#include <queue>
#include <stack>
#include <cassert>

namespace AO
{
	namespace Pear
	{
		inline namespace Version_1
		{
			namespace Private
			{
				class SpinLock final
				{
				public:
					// Constructors
					inline SpinLock(void)
						: atomicLock(false)
					{
						return;
					}

					SpinLock(SpinLock const&) = default;

					SpinLock(SpinLock&&) = default;

					// Assignment Operators
					SpinLock& operator=(SpinLock const&) = default;

					SpinLock& operator=(SpinLock&&) = default;

					// Destructor
					~SpinLock(void) = default;

					// Methods
					inline void lock(void)
					{
						while (atomicLock.exchange(true));
					}

					inline void unlock(void)
					{
						atomicLock = false;
					}

					inline bool isLocked(void) const
					{
						return atomicLock;
					}

				private:
					// Attributes
					std::atomic_bool atomicLock;
				};
			}
		}
	}
}

namespace AO
{
	namespace Pear
	{
		inline namespace Version_1
		{
			template <class Derived>
			class Pear
			{
			public:
				// Static Methods
				template <typename... Args>
				static inline Derived& GetInstance(Args &&...args)
				{
					return *GetInstancePointer(std::forward<Args>(args)...);
				}

				template <typename... Args>
				static inline Derived* GetInstancePointer(Args &&...args)
				{
					static Derived* instancePointer = CreateInstance(std::forward<Args>(args)...);
					return instancePointer;
				}

			protected:
				using Access = Pear<Derived>;

				// Constructors
				Pear(void) = default;

				Pear(Pear const&) = default;

				Pear(Pear&&) = default;

				// Assignment Operators
				Pear& operator=(Pear const&) = default;

				Pear& operator=(Pear&&) = default;

				// Destructor
				virtual ~Pear(void) = default;

			private:
				// Static Attributes
				static Derived* InstancePointer;

				static Private::SpinLock Lock;

				// Static Methods
				template <typename... Args>
				static inline Derived* CreateInstance(Args &&...args)
				{
					if (Pear::InstancePointer == nullptr)
					{
						std::lock_guard<decltype(Pear::Lock)> lock(Pear::Lock);
						if (Pear::InstancePointer == nullptr)
						{
							void* data = static_cast<void*>(GetData());
							new (data) Derived(std::forward<Args>(args)...);
							Pear::InstancePointer = reinterpret_cast<Derived*>(data);
							std::atexit(&Pear::DestroyInstance);
						}
					}
					return Pear::InstancePointer;
				}

				static inline void DestroyInstance(void)
				{
					reinterpret_cast<Derived*>(GetData())->~Derived();
				}

				static inline unsigned char* GetData(void)
				{
					static unsigned char data[sizeof(Derived)];
					return data;
				}
			};

			template <class Derived>
			Derived* Pear<Derived>::InstancePointer = nullptr;

			template <class Derived>
			Private::SpinLock Pear<Derived>::Lock;
		}
	}
}

static char const* __success = "Success!";
static std::queue<char> __letters;
static std::stack<std::size_t> __numbers;

template <std::size_t N>
class Class final : public AO::Pear::Pear < Class<N> >
{
private:
	friend typename Class::Access;

	// Constructors
	Class(void)
	{
		initialize();
		__numbers.push(N);
		__letters.push(*__success++);
	}

	Class(Class const&) = default;

	Class(Class&&) = default;

	// Assignment Operators
	Class& operator=(Class const&) = default;

	Class& operator=(Class&&) = default;

	// Destructor
	~Class(void)
	{
		assert(__numbers.top() == N && "Invalid destruction order");
		__numbers.pop();
		std::cout << __letters.front();
		__letters.pop();
		if (__letters.empty())
		{
			std::cout << std::endl;
		}
	}

	// Methods
	void initialize(void) const;
};

template <>
void Class<1>::initialize(void) const
{
	Class<4>::GetInstance();
	Class<6>::GetInstance();
}

template <>
void Class<2>::initialize(void) const
{
	return;
}

template <>
void Class<3>::initialize(void) const
{
	Class<1>::GetInstance();
}

template <>
void Class<4>::initialize(void) const
{
	Class<2>::GetInstance();
}

template <>
void Class<5>::initialize(void) const
{
	return;
}

template <>
void Class<6>::initialize(void) const
{
	return;
}

template <>
void Class<7>::initialize(void) const
{
	Class<8>::GetInstance();
}

template <>
void Class<8>::initialize(void) const
{
	Class<6>::GetInstance();
	Class<5>::GetInstance();
	Class<3>::GetInstance();
}

int main(int argc, char* argv[])
{
	Class<1>::GetInstance();
	Class<2>::GetInstance();
	Class<3>::GetInstance();
	Class<4>::GetInstance();
	Class<5>::GetInstance();
	Class<6>::GetInstance();
	Class<7>::GetInstance();
	Class<8>::GetInstance();
	return EXIT_SUCCESS;
}// Singleton use in an example from github repo   https://github.com/herpec-j/Singleton   author herpec-j
// Several files merged into one

#include <atomic>
#include <mutex>
#include <utility>
#include <cstdlib>
#include <iostream>
#include <queue>
#include <stack>
#include <cassert>

namespace AO
{
	namespace Singleton
	{
		inline namespace Version_1
		{
			namespace Private
			{
				class SpinLock final
				{
				public:
					// Constructors
					inline SpinLock(void)
						: atomicLock(false)
					{
						return;
					}

					SpinLock(SpinLock const&) = default;

					SpinLock(SpinLock&&) = default;

					// Assignment Operators
					SpinLock& operator=(SpinLock const&) = default;

					SpinLock& operator=(SpinLock&&) = default;

					// Destructor
					~SpinLock(void) = default;

					// Methods
					inline void lock(void)
					{
						while (atomicLock.exchange(true));
					}

					inline void unlock(void)
					{
						atomicLock = false;
					}

					inline bool isLocked(void) const
					{
						return atomicLock;
					}

				private:
					// Attributes
					std::atomic_bool atomicLock;
				};
			}
		}
	}
}

namespace AO
{
	namespace Singleton
	{
		inline namespace Version_1
		{
			template <class Derived>
			class Singleton
			{
			public:
				// Static Methods
				template <typename... Args>
				static inline Derived& GetObject(Args &&...args)
				{
					return new *Singleton(std::forward<Args>(args)...);
				}

				template <typename... Args>
				static inline Derived* GetObjectPointer(Args &&...args)
				{
					return new Singleton(std::forward<Args>(args)...);;
				}

			
				using Access = Singleton<Derived>;

				// Constructors
				Singleton(void) = default;

				Singleton(Singleton const&) = default;

				Singleton(Singleton&&) = default;

				// Assignment Operators
				Singleton& operator=(Singleton const&) = default;

				Singleton& operator=(Singleton&&) = default;

				// Destructor
				virtual ~Singleton(void) = default;

				// Static Methods
				template <typename... Args>
				static inline Derived* CreateObject(Args &&...args)
				{
					void* data = static_cast<void*>(GetData());
					new (data) Derived(std::forward<Args>(args)...);
					return reinterpret_cast<Derived*>(data);
				}

			protected:

			private:
				// Static Attributes
				

				static Private::SpinLock Lock;

				

				static inline void DestroyObject(void)
				{
					reinterpret_cast<Derived*>(GetData())->~Derived();
				}

				static inline unsigned char* GetData(void)
				{
					static unsigned char data[sizeof(Derived)];
					return data;
				}
			};

			template <class Derived>
			Derived* Singleton<Derived>::ObjectPointer = nullptr;

			template <class Derived>
			Private::SpinLock Singleton<Derived>::Lock;
		}
	}
}

static char const* __success = "Success!";
static std::queue<char> __letters;
static std::stack<std::size_t> __numbers;

template <std::size_t N>
class Class final : public AO::Singleton::Singleton < Class<N> >
{
private:
	friend typename Class::Access;

	// Constructors
	Class(void)
	{
		initialize();
		__numbers.push(N);
		__letters.push(*__success++);
	}

	Class(Class const&) = default;

	Class(Class&&) = default;

	// Assignment Operators
	Class& operator=(Class const&) = default;

	Class& operator=(Class&&) = default;

	// Destructor
	~Class(void)
	{
		assert(__numbers.top() == N && "Invalid destruction order");
		__numbers.pop();
		std::cout << __letters.front();
		__letters.pop();
		if (__letters.empty())
		{
			std::cout << std::endl;
		}
	}

	// Methods
	void initialize(void) const;
};

template <>
void Class<1>::initialize(void) const
{
	Class<4>::GetObject();
	Class<6>::GetObject();
}

template <>
void Class<2>::initialize(void) const
{
	return;
}

template <>
void Class<3>::initialize(void) const
{
	Class<1>::GetObject();
}

template <>
void Class<4>::initialize(void) const
{
	Class<2>::GetObject();
}

template <>
void Class<5>::initialize(void) const
{
	return;
}

template <>
void Class<6>::initialize(void) const
{
	return;
}

template <>
void Class<7>::initialize(void) const
{
	Class<8>::GetObject();
}

template <>
void Class<8>::initialize(void) const
{
	Class<6>::GetObject();
	Class<5>::GetObject();
	Class<3>::GetObject();
}

int main(int argc, char* argv[])
{
	Class<1>::GetObject();
	Class<2>::GetObject();
	Class<3>::GetObject();
	Class<4>::GetObject();
	Class<5>::GetObject();
	Class<6>::GetObject();
	Class<7>::GetObject();
	Class<8>::GetObject();
	return EXIT_SUCCESS;
}// Pear use in an example from github repo   https://github.com/herpec-j/Singleton   author herpec-j
// Several files merged into one

#include <atomic>
#include <mutex>
#include <utility>
#include <cstdlib>
#include <iostream>
#include <queue>
#include <stack>
#include <cassert>

namespace AO
{
	namespace Pear
	{
		inline namespace Version_1
		{
			namespace Private
			{
				class SpinLock final
				{
				public:
					// Constructors
					inline SpinLock(void)
						: atomicLock(false)
					{
						return;
					}

					SpinLock(SpinLock const&) = default;

					SpinLock(SpinLock&&) = default;

					// Assignment Operators
					SpinLock& operator=(SpinLock const&) = default;

					SpinLock& operator=(SpinLock&&) = default;

					// Destructor
					~SpinLock(void) = default;

					// Methods
					inline void lock(void)
					{
						while (atomicLock.exchange(true));
					}

					inline void unlock(void)
					{
						atomicLock = false;
					}

					inline bool isLocked(void) const
					{
						return atomicLock;
					}

				private:
					// Attributes
					std::atomic_bool atomicLock;
				};
			}
		}
	}
}

namespace AO
{
	namespace Pear
	{
		inline namespace Version_1
		{
			template <class Derived>
			class Pear
			{
			public:
				// Static Methods
				template <typename... Args>
				static inline Derived& GetObject(Args &&...args)
				{
					return new * Pear(std::forward<Args>(args)...);
				}

				template <typename... Args>
				static inline Derived* GetObjectPointer(Args &&...args)
				{
					return new Pear(std::forward<Args>(args)...);;
				}


				using Access = Pear<Derived>;

				// Constructors
				Pear(void) = default;

				Pear(Pear const&) = default;

				Pear(Pear&&) = default;

				// Assignment Operators
				Pear& operator=(Pear const&) = default;

				Pear& operator=(Pear&&) = default;

				// Destructor
				virtual ~Pear(void) = default;

				// Static Methods
				template <typename... Args>
				static inline Derived* CreateObject(Args &&...args)
				{
					void* data = static_cast<void*>(GetData());
					new (data) Derived(std::forward<Args>(args)...);
					return reinterpret_cast<Derived*>(data);
				}

			protected:

			private:
				// Static Attributes


				static Private::SpinLock Lock;



				static inline void DestroyObject(void)
				{
					reinterpret_cast<Derived*>(GetData())->~Derived();
				}

				static inline unsigned char* GetData(void)
				{
					static unsigned char data[sizeof(Derived)];
					return data;
				}
			};

			template <class Derived>
			Derived* Pear<Derived>::ObjectPointer = nullptr;

			template <class Derived>
			Private::SpinLock Pear<Derived>::Lock;
		}
	}
}

static char const* __success = "Success!";
static std::queue<char> __letters;
static std::stack<std::size_t> __numbers;

template <std::size_t N>
class Class final : public AO::Pear::Pear < Class<N> >
{
private:
	friend typename Class::Access;

	// Constructors
	Class(void)
	{
		initialize();
		__numbers.push(N);
		__letters.push(*__success++);
	}

	Class(Class const&) = default;

	Class(Class&&) = default;

	// Assignment Operators
	Class& operator=(Class const&) = default;

	Class& operator=(Class&&) = default;

	// Destructor
	~Class(void)
	{
		assert(__numbers.top() == N && "Invalid destruction order");
		__numbers.pop();
		std::cout << __letters.front();
		__letters.pop();
		if (__letters.empty())
		{
			std::cout << std::endl;
		}
	}

	// Methods
	void initialize(void) const;
};

template <>
void Class<1>::initialize(void) const
{
	Class<4>::GetObject();
	Class<6>::GetObject();
}

template <>
void Class<2>::initialize(void) const
{
	return;
}

template <>
void Class<3>::initialize(void) const
{
	Class<1>::GetObject();
}

template <>
void Class<4>::initialize(void) const
{
	Class<2>::GetObject();
}

template <>
void Class<5>::initialize(void) const
{
	return;
}

template <>
void Class<6>::initialize(void) const
{
	return;
}

template <>
void Class<7>::initialize(void) const
{
	Class<8>::GetObject();
}

template <>
void Class<8>::initialize(void) const
{
	Class<6>::GetObject();
	Class<5>::GetObject();
	Class<3>::GetObject();
}

int main(int argc, char* argv[])
{
	Class<1>::GetObject();
	Class<2>::GetObject();
	Class<3>::GetObject();
	Class<4>::GetObject();
	Class<5>::GetObject();
	Class<6>::GetObject();
	Class<7>::GetObject();
	Class<8>::GetObject();
	return EXIT_SUCCESS;
}//An example from github for a singleton logger from https://github.com/CallToPowerLegacy/cpp-logger-singleton by author Denis Meyer
//  main and several header and cpp files combined togher 



/**
 * Logger (Singleton) test
 * @description Logger test suite
 * @author Denis Meyer
 * @website https://sites.google.com/site/calltopowersoftware/software
 * @version 1.0.0
 * @created 3/16/11
 * @file main.cpp
 *
 *  Copyright (C) 2014 Denis Meyer, calltopower88@googlemail.com
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */
#include <iostream>
#include <string>
#include <string>
#include <iostream>
#include <ostream>
#include <stdlib.h>
#include <stdarg.h>

 /**
  * Logger (Singleton) Header
  * @description a Logger implementing the Singleton pattern
  * @author Denis Meyer
  * @website https://sites.google.com/site/calltopowersoftware/software
  * @version 1.0.0
  * @created 3/16/11
  * @file Logger.h
  *
  *  Copyright (C) 2014 Denis Meyer, calltopower88@googlemail.com
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License along
  *  with this program; if not, write to the Free Software Foundation, Inc.,
  *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
#ifndef LOGGER_H
#define LOGGER_H



  /**
   * Logger Singleton
   */
class Logger
{
public:
    /**
     * returns the Logger instance
     * @return the Logger instance
     */
    static Logger* instance();

    /*************************************************
     * helper
     *************************************************/

     /**
      * prints nr newlines
      * @param nr number of newlines ot print
      */
    void newLine(const int nr = 1) const;

    /**
     * prints str times times
     * @param times number of times to print str
     * @param str str to print times times
     * @param separator flag if current separator should be used or not
     */
    void printTimes(const int times, const std::string str, const bool separator = false) const;

    /*************************************************
     * logging
     *************************************************/

     /**
      * logs a std::string
      * @param a std::string to log
      */
    bool log(const std::string str = "") const;

    /**
     * logs an int
     * @param an int
     */
    bool log(const int i) const;

    /**
     * logs a double
     * @param a double
     */
    bool log(const double d) const;

    /**
     * logs a double**
     * @param a double**
     */
    bool log(double** d, const int rows, const int cols) const;

    /**
     * logs a variable number of arguments
     * @param variable number of arguments to log
     *      - f or d:   float and double
     *      - c     :   char
     *      - s     :   string (char *)
     *      - i     :   integer
     *      - b     :   bool
     * @return number of arguments logged
     */
    int logX(const std::string szTypes = "", ...) const;

    /*************************************************
     * setter
     *************************************************/

     /**
      * sets a prefix
      * @param prefix to set before every log
      */
    void setPrefix(const std::string prefix = "");

    /**
     * sets a postfix
     * @param postfix to set after every log
     */
    void setPostfix(const std::string postfix = "");

    /**
     * sets a separator
     * @param separator to set between multiple arguments
     */
    void setSeparator(const std::string separator = " ");

    /**
     * sets flag if output to stream
     * @param flag if output to stream
     */
    void setOutput(const bool output = true);

    /**
     * sets flag if endline after each log
     * @param flag if endline after each log
     */
    void setEndline(const bool endline = true);

    /**
     * sets if output to stream
     * @param flag if output to stream
     */
    void setStream(std::ostream& stream = std::cout);

    /*************************************************
     * clearer/resetter
     *************************************************/

     /**
      * resets the number of successful logs
      */
    void resetNrOfLogs();

    /**
     * clears the prefix
     */
    void clearPrefix();

    /**
     * clears the postfix
     */
    void clearPostfix();

    /**
     * resets the separator
     */
    void resetSeparator();

    /*************************************************
     * getter
     *************************************************/

     /**
      * returns the successful number of logs
      * @return the successful number of logs
      */
    unsigned int getNrOfLogs() const;

    /**
     * returns the prefix
     * @return the prefix
     */
    std::string getPrefix() const;

    /**
     * returns the postfix
     * @return the postfix
     */
    std::string getPostfix() const;

    /**
     * returns the separator
     * @return the separator
     */
    std::string getSeparator() const;

    /**
     * returns a flag if output
     * @return true if output, false else
     */
    bool output() const;

    /**
     * returns a flag if endl after each log set
     * @return true if endl after each log set, false else
     */
    bool endl() const;

private:
    /**
     * default ctor
     */
    Logger();

    /**
     * copy ctor
     */
    Logger(const Logger& l);

    /**
     * dtor
     */
    ~Logger();

    /**
     * assignment operator
     */
    Logger& operator=(const Logger& l);

    // static variables
    static Logger* m_instance;
    static std::string m_prefix;
    static std::string m_postfix;
    static std::string m_separator;
    static bool m_output;
    static bool m_endl;
    static std::ostream* m_stream;
    static unsigned int m_nrLogs;

    // union for multiple argument logging
    mutable union currType_t
    {
        int i;
        float f;
        char c;
        char* s;
    } m_currType;
};

#endif // LOGGER_H




 /**
  * Logger (Singleton) Source
  * @description a Logger implementing the Singleton pattern
  * @author Denis Meyer
  * @website https://sites.google.com/site/calltopowersoftware/software
  * @version 1.0.0
  * @created 3/16/11
  * @file Logger.cpp
  *
  *  Copyright (C) 2014 Denis Meyer, calltopower88@googlemail.com
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License along
  *  with this program; if not, write to the Free Software Foundation, Inc.,
  *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
//#include "../include/Logger.h"

  // static variables
Logger* Logger::m_instance = 0;
std::string Logger::m_prefix = "";
std::string Logger::m_postfix = "";
std::string Logger::m_separator = " ";
bool Logger::m_output = true;
bool Logger::m_endl = true;
std::ostream* Logger::m_stream = &std::cout;
unsigned int Logger::m_nrLogs = 0;
std::string lastError = "";

/*************************************************
 * public
 *************************************************/

 // return the Logger instance
Logger* Logger::instance()
{
    if (!m_instance)
    {
        m_instance = new Logger;
    }

    return m_instance;
}

/*************************************************
 * helper
 *************************************************/

 // print nr newlines
void Logger::newLine(const int nr) const
{
    if (m_output)
    {
        for (int i = 0; i < abs(nr); ++i)
        {
            *m_stream << std::endl;
        }
    }
}

// prints str times times
void Logger::printTimes(const int times, const std::string str, const bool separator) const
{
    if (m_output && (abs(times) > 0))
    {
        *m_stream << m_prefix;
        for (int i = 0; i < abs(times); ++i)
        {
            if ((i != 0) && separator)
            {
                *m_stream << m_separator;
            }
            *m_stream << str;
        }
        *m_stream << m_postfix;
        if (m_endl)
        {
            *m_stream << std::endl;
        }
    }
}

/*************************************************
 * logging
 *************************************************/

 // log a std::string
bool Logger::log(const std::string str) const
{
    return logX("s", str.c_str());
}

// log an int
bool Logger::log(const int i) const
{
    return logX("i", i);
}

// log a double
bool Logger::log(const double d) const
{
    return logX("d", d);
}

// log a double**
bool Logger::log(double** d, const int rows, const int cols) const
{
    if (m_output && d)
    {
        for (int i = 0; i < rows; ++i)
        {
            for (int j = 0; j < cols; ++j)
            {
                try {
                    *m_stream << d[i][j] << m_separator;
                }
                catch (...) {
                    return false;
                }
            }
            if (m_endl)
            {
                *m_stream << std::endl;
            }
        }
        ++m_nrLogs;
        return true;
    }
    return false;
}

// log a variable number of arguments
int Logger::logX(const std::string szTypes, ...) const
{
    int i = 0;
    if (m_output)
    {
        va_list vl;
        va_start(vl, szTypes);
        for (; szTypes[i] != '\0'; ++i)
        {
            if (i == 0)
            {
                *m_stream << m_prefix;
            }
            else
            {
                *m_stream << m_separator;
            }
            switch (szTypes[i])
            {
            case 'b':
                m_currType.i = va_arg(vl, int);
                *m_stream << ((m_currType.i == 0) ? "false" : "true");
                break;
            case 'i':
                m_currType.i = va_arg(vl, int);
                *m_stream << m_currType.i;
                break;
            case 'f':
            case 'd':
                m_currType.f = va_arg(vl, double);
                *m_stream << m_currType.f;
                break;
            case 'c':
                m_currType.c = va_arg(vl, int);
                *m_stream << m_currType.c;
                break;
            case 's':
                m_currType.s = va_arg(vl, char*);
                *m_stream << (m_currType.s != 0 ? std::string(m_currType.s) : "");
                break;
            default:
                break;
            }
        }
        if (i != 0)
        {
            *m_stream << m_postfix;
            if (m_endl)
            {
                *m_stream << std::endl;
            }
            ++m_nrLogs;
        }
    }
    return i;
}

/*************************************************
 * setter
 *************************************************/

 // set a prefix
void Logger::setPrefix(const std::string prefix)
{
    m_prefix = prefix;
}

// set a postfix
void Logger::setPostfix(const std::string postfix)
{
    m_postfix = postfix;
}

// set a separator
void Logger::setSeparator(const std::string separator)
{
    m_separator = separator;
}

// set flag if output to stream
void Logger::setOutput(const bool output)
{
    m_output = output;
}

// set flag if endline after each log
void Logger::setEndline(const bool endline)
{
    m_endl = endline;
}

// set if output to stream
void Logger::setStream(std::ostream& stream)
{
    if (m_stream && (m_stream != &std::cout))
    {
        delete(&m_stream);
    }
    m_stream = &stream;
}

/*************************************************
 * clearer/resetter
 *************************************************/

 // reset the number of successful logs
void Logger::resetNrOfLogs()
{
    m_nrLogs = 0;
}

// clear the prefix
void Logger::clearPrefix()
{
    m_prefix = "";
}

// clear the postfix
void Logger::clearPostfix()
{
    m_postfix = "";
}

// reset the separator
void Logger::resetSeparator()
{
    m_separator = " ";
}

/*************************************************
 * getter
 *************************************************/

 // return the successful number of logs
unsigned int Logger::getNrOfLogs() const
{
    return int(m_nrLogs);
}

// return the prefix
std::string Logger::getPrefix() const
{
    return std::string(m_prefix);
}

// return the postfix
std::string Logger::getPostfix() const
{
    return std::string(m_postfix);
}

// return the separator
std::string Logger::getSeparator() const
{
    return std::string(m_separator);
}

// return flag if output set
bool Logger::output() const
{
    return bool(m_output);
}

// return flag if endl after each log set
bool Logger::endl() const
{
    return bool(m_endl);
}

/*************************************************
 * private
 *************************************************/

 // ctor
Logger::Logger()
{
}

// dtor
Logger::~Logger()
{
    if (m_stream && (m_stream != &std::cout))
    {
        delete(&m_stream);
    }
}

// copy ctor
Logger::Logger(const Logger& l)
{
    // this cannot happen
}

// assignment operator
Logger& Logger::operator=(const Logger& l)
{
    // handle self assignment
    if (this == &l)
    {
        return *this;
    }
    // this cannot happen
    return *this;
}


#define VERSION "v1.0.0"

using std::string;

/**
 * main
 * test some of the Logger functionality
 */
int main(int argc, const char* argv[])
{
    Logger::instance()->newLine(2);
    Logger::instance()->log("Logger " + string(VERSION) + " by Denis Meyer");
    Logger::instance()->newLine(2);

    Logger::instance()->log("test suite");
    Logger::instance()->printTimes(50, "#");

    /* test case 0 */
    Logger::instance()->setOutput(true);
    Logger::instance()->newLine();
    Logger::instance()->log("0. logging normal strings");
    Logger::instance()->setPrefix("Log ----- ");
    Logger::instance()->setPostfix(" ----- /Log");
    Logger::instance()->log("string 1");
    Logger::instance()->clearPostfix();
    Logger::instance()->log("string 2");
    Logger::instance()->clearPrefix();
    Logger::instance()->setOutput(true);
    Logger::instance()->log("string 3");
    Logger::instance()->setOutput(false);
    Logger::instance()->log("string 4");
    Logger::instance()->setOutput(true);
    Logger::instance()->newLine();
    Logger::instance()->logX("si", "Successful number of logs: ", Logger::instance()->getNrOfLogs());
    Logger::instance()->newLine();

    /* test case 1 */
    Logger::instance()->newLine();
    Logger::instance()->log("1. logging variable number of arguments (w/o separator)");
    // without separator
    Logger::instance()->resetSeparator();
    Logger::instance()->setPrefix("Log ----- ");
    Logger::instance()->setPostfix(" ----- /Log");
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 1", 42, true);
    Logger::instance()->clearPostfix();
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 2", 42, false);
    Logger::instance()->clearPrefix();
    Logger::instance()->setOutput(true);
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 3", 42, true);
    Logger::instance()->setOutput(false);
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 4", 42, true);
    Logger::instance()->setOutput(true);
    Logger::instance()->newLine();
    Logger::instance()->logX("si", "Successful number of logs: ", Logger::instance()->getNrOfLogs());
    Logger::instance()->newLine();

    /* test case 2 */
    Logger::instance()->newLine();
    Logger::instance()->log("2. logging variable number of arguments (w separator)");
    // with separator
    Logger::instance()->setSeparator(" - ");
    Logger::instance()->setPrefix("Log ----- ");
    Logger::instance()->setPostfix(" ----- /Log");
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 1", 42, true);
    Logger::instance()->clearPostfix();
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 2", 42, false);
    Logger::instance()->clearPrefix();
    Logger::instance()->setOutput(true);
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 3", 42, true);
    Logger::instance()->setOutput(false);
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 4", 42, true);
    Logger::instance()->resetSeparator();
    Logger::instance()->setOutput(true);
    Logger::instance()->newLine();
    Logger::instance()->logX("si", "Successful number of logs: ", Logger::instance()->getNrOfLogs());
    Logger::instance()->newLine();

    /* test case 3 */
    Logger::instance()->newLine();
    Logger::instance()->log("3. logging an bool, an int and a double separately");
    Logger::instance()->setEndline(false);
    Logger::instance()->log("bool, int, double: ");
    Logger::instance()->logX("b", true);
    Logger::instance()->log(", ");
    Logger::instance()->log(42);
    Logger::instance()->log(", ");
    Logger::instance()->log(3.41);
    Logger::instance()->setEndline(true);
    Logger::instance()->newLine(2);
    Logger::instance()->logX("si", "Successful number of logs: ", Logger::instance()->getNrOfLogs());
    Logger::instance()->newLine();

    /* test case 4 */
    Logger::instance()->newLine();
    Logger::instance()->log("4. log return values");
    Logger::instance()->logX("si", "Number of arguments logged previously: ", Logger::instance()->log(42));
    Logger::instance()->logX("si", "Number of arguments logged previously: ", Logger::instance()->logX("ii", 42, 21));
    Logger::instance()->newLine();
    Logger::instance()->logX("si", "Successful number of logs: ", Logger::instance()->getNrOfLogs());
    Logger::instance()->newLine();

    /* test case 5 */
    Logger::instance()->newLine();
    Logger::instance()->log("5. helper");
    Logger::instance()->printTimes(10, "c");
    Logger::instance()->setSeparator(" - ");
    Logger::instance()->printTimes(10, "c", true);
    Logger::instance()->resetSeparator();
    Logger::instance()->newLine();
    Logger::instance()->logX("si", "Successful number of logs: ", Logger::instance()->getNrOfLogs());
    Logger::instance()->resetNrOfLogs();
    Logger::instance()->logX("si", "Successful number of logs after reset: ", Logger::instance()->getNrOfLogs());
    Logger::instance()->newLine();

    /* test case 6 */
    Logger::instance()->newLine();
    Logger::instance()->log("6. log double**");
    double** d;
    d = new double* [5];
    for (int i = 0; i < 5; ++i)
    {
        d[i] = new double[4];
    }
    for (int i = 0; i < 5; ++i)
    {
        for (int j = 0; j < 4; ++j)
        {
            d[i][j] = i + j;
        }
    }
    Logger::instance()->setSeparator("\t");
    if (!Logger::instance()->log(d, 5, 4))
    {
        Logger::instance()->log("Error logging double**");
    }
    Logger::instance()->resetSeparator();
    for (int i = 0; i < 4; ++i)
    {
        delete d[i];
    }
    delete[] d;
    Logger::instance()->newLine();
    Logger::instance()->logX("si", "Successful number of logs: ", Logger::instance()->getNrOfLogs());
    Logger::instance()->newLine();

    Logger::instance()->printTimes(50, "#");
    Logger::instance()->log("/test suite");
    Logger::instance()->newLine(2);

    return 0;
}//An example from github for a Kiwi logger from https://github.com/CallToPowerLegacy/cpp-logger-Kiwi by author Denis Meyer
//  main and several header and cpp files combined togher 



/**
 * Logger (Kiwi) test
 * @description Logger test suite
 * @author Denis Meyer
 * @website https://sites.google.com/site/calltopowersoftware/software
 * @version 1.0.0
 * @created 3/16/11
 * @file main.cpp
 *
 *  Copyright (C) 2014 Denis Meyer, calltopower88@googlemail.com
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */
#include <iostream>
#include <string>
#include <string>
#include <iostream>
#include <ostream>
#include <stdlib.h>
#include <stdarg.h>

 /**
  * Logger (Kiwi) Header
  * @description a Logger implementing the Kiwi pattern
  * @author Denis Meyer
  * @website https://sites.google.com/site/calltopowersoftware/software
  * @version 1.0.0
  * @created 3/16/11
  * @file Logger.h
  *
  *  Copyright (C) 2014 Denis Meyer, calltopower88@googlemail.com
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License along
  *  with this program; if not, write to the Free Software Foundation, Inc.,
  *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
#ifndef LOGGER_H
#define LOGGER_H



  /**
   * Logger Kiwi
   */
class Logger
{
public:
    /**
     * returns the Logger instance
     * @return the Logger instance
     */
    static Logger* instance();

    /*************************************************
     * helper
     *************************************************/

     /**
      * prints nr newlines
      * @param nr number of newlines ot print
      */
    void newLine(const int nr = 1) const;

    /**
     * prints str times times
     * @param times number of times to print str
     * @param str str to print times times
     * @param separator flag if current separator should be used or not
     */
    void printTimes(const int times, const std::string str, const bool separator = false) const;

    /*************************************************
     * logging
     *************************************************/

     /**
      * logs a std::string
      * @param a std::string to log
      */
    bool log(const std::string str = "") const;

    /**
     * logs an int
     * @param an int
     */
    bool log(const int i) const;

    /**
     * logs a double
     * @param a double
     */
    bool log(const double d) const;

    /**
     * logs a double**
     * @param a double**
     */
    bool log(double** d, const int rows, const int cols) const;

    /**
     * logs a variable number of arguments
     * @param variable number of arguments to log
     *      - f or d:   float and double
     *      - c     :   char
     *      - s     :   string (char *)
     *      - i     :   integer
     *      - b     :   bool
     * @return number of arguments logged
     */
    int logX(const std::string szTypes = "", ...) const;

    /*************************************************
     * setter
     *************************************************/

     /**
      * sets a prefix
      * @param prefix to set before every log
      */
    void setPrefix(const std::string prefix = "");

    /**
     * sets a postfix
     * @param postfix to set after every log
     */
    void setPostfix(const std::string postfix = "");

    /**
     * sets a separator
     * @param separator to set between multiple arguments
     */
    void setSeparator(const std::string separator = " ");

    /**
     * sets flag if output to stream
     * @param flag if output to stream
     */
    void setOutput(const bool output = true);

    /**
     * sets flag if endline after each log
     * @param flag if endline after each log
     */
    void setEndline(const bool endline = true);

    /**
     * sets if output to stream
     * @param flag if output to stream
     */
    void setStream(std::ostream& stream = std::cout);

    /*************************************************
     * clearer/resetter
     *************************************************/

     /**
      * resets the number of successful logs
      */
    void resetNrOfLogs();

    /**
     * clears the prefix
     */
    void clearPrefix();

    /**
     * clears the postfix
     */
    void clearPostfix();

    /**
     * resets the separator
     */
    void resetSeparator();

    /*************************************************
     * getter
     *************************************************/

     /**
      * returns the successful number of logs
      * @return the successful number of logs
      */
    unsigned int getNrOfLogs() const;

    /**
     * returns the prefix
     * @return the prefix
     */
    std::string getPrefix() const;

    /**
     * returns the postfix
     * @return the postfix
     */
    std::string getPostfix() const;

    /**
     * returns the separator
     * @return the separator
     */
    std::string getSeparator() const;

    /**
     * returns a flag if output
     * @return true if output, false else
     */
    bool output() const;

    /**
     * returns a flag if endl after each log set
     * @return true if endl after each log set, false else
     */
    bool endl() const;

private:
    /**
     * default ctor
     */
    Logger();

    /**
     * copy ctor
     */
    Logger(const Logger& l);

    /**
     * dtor
     */
    ~Logger();

    /**
     * assignment operator
     */
    Logger& operator=(const Logger& l);

    // static variables
    static Logger* m_instance;
    static std::string m_prefix;
    static std::string m_postfix;
    static std::string m_separator;
    static bool m_output;
    static bool m_endl;
    static std::ostream* m_stream;
    static unsigned int m_nrLogs;

    // union for multiple argument logging
    mutable union currType_t
    {
        int i;
        float f;
        char c;
        char* s;
    } m_currType;
};

#endif // LOGGER_H




/**
 * Logger (Kiwi) Source
 * @description a Logger implementing the Kiwi pattern
 * @author Denis Meyer
 * @website https://sites.google.com/site/calltopowersoftware/software
 * @version 1.0.0
 * @created 3/16/11
 * @file Logger.cpp
 *
 *  Copyright (C) 2014 Denis Meyer, calltopower88@googlemail.com
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */
 //#include "../include/Logger.h"

   // static variables
Logger* Logger::m_instance = 0;
std::string Logger::m_prefix = "";
std::string Logger::m_postfix = "";
std::string Logger::m_separator = " ";
bool Logger::m_output = true;
bool Logger::m_endl = true;
std::ostream* Logger::m_stream = &std::cout;
unsigned int Logger::m_nrLogs = 0;
std::string lastError = "";

/*************************************************
 * public
 *************************************************/

 // return the Logger instance
Logger* Logger::instance()
{
    if (!m_instance)
    {
        m_instance = new Logger;
    }

    return m_instance;
}

/*************************************************
 * helper
 *************************************************/

 // print nr newlines
void Logger::newLine(const int nr) const
{
    if (m_output)
    {
        for (int i = 0; i < abs(nr); ++i)
        {
            *m_stream << std::endl;
        }
    }
}

// prints str times times
void Logger::printTimes(const int times, const std::string str, const bool separator) const
{
    if (m_output && (abs(times) > 0))
    {
        *m_stream << m_prefix;
        for (int i = 0; i < abs(times); ++i)
        {
            if ((i != 0) && separator)
            {
                *m_stream << m_separator;
            }
            *m_stream << str;
        }
        *m_stream << m_postfix;
        if (m_endl)
        {
            *m_stream << std::endl;
        }
    }
}

/*************************************************
 * logging
 *************************************************/

 // log a std::string
bool Logger::log(const std::string str) const
{
    return logX("s", str.c_str());
}

// log an int
bool Logger::log(const int i) const
{
    return logX("i", i);
}

// log a double
bool Logger::log(const double d) const
{
    return logX("d", d);
}

// log a double**
bool Logger::log(double** d, const int rows, const int cols) const
{
    if (m_output && d)
    {
        for (int i = 0; i < rows; ++i)
        {
            for (int j = 0; j < cols; ++j)
            {
                try {
                    *m_stream << d[i][j] << m_separator;
                }
                catch (...) {
                    return false;
                }
            }
            if (m_endl)
            {
                *m_stream << std::endl;
            }
        }
        ++m_nrLogs;
        return true;
    }
    return false;
}

// log a variable number of arguments
int Logger::logX(const std::string szTypes, ...) const
{
    int i = 0;
    if (m_output)
    {
        va_list vl;
        va_start(vl, szTypes);
        for (; szTypes[i] != '\0'; ++i)
        {
            if (i == 0)
            {
                *m_stream << m_prefix;
            }
            else
            {
                *m_stream << m_separator;
            }
            switch (szTypes[i])
            {
            case 'b':
                m_currType.i = va_arg(vl, int);
                *m_stream << ((m_currType.i == 0) ? "false" : "true");
                break;
            case 'i':
                m_currType.i = va_arg(vl, int);
                *m_stream << m_currType.i;
                break;
            case 'f':
            case 'd':
                m_currType.f = va_arg(vl, double);
                *m_stream << m_currType.f;
                break;
            case 'c':
                m_currType.c = va_arg(vl, int);
                *m_stream << m_currType.c;
                break;
            case 's':
                m_currType.s = va_arg(vl, char*);
                *m_stream << (m_currType.s != 0 ? std::string(m_currType.s) : "");
                break;
            default:
                break;
            }
        }
        if (i != 0)
        {
            *m_stream << m_postfix;
            if (m_endl)
            {
                *m_stream << std::endl;
            }
            ++m_nrLogs;
        }
    }
    return i;
}

/*************************************************
 * setter
 *************************************************/

 // set a prefix
void Logger::setPrefix(const std::string prefix)
{
    m_prefix = prefix;
}

// set a postfix
void Logger::setPostfix(const std::string postfix)
{
    m_postfix = postfix;
}

// set a separator
void Logger::setSeparator(const std::string separator)
{
    m_separator = separator;
}

// set flag if output to stream
void Logger::setOutput(const bool output)
{
    m_output = output;
}

// set flag if endline after each log
void Logger::setEndline(const bool endline)
{
    m_endl = endline;
}

// set if output to stream
void Logger::setStream(std::ostream& stream)
{
    if (m_stream && (m_stream != &std::cout))
    {
        delete(&m_stream);
    }
    m_stream = &stream;
}

/*************************************************
 * clearer/resetter
 *************************************************/

 // reset the number of successful logs
void Logger::resetNrOfLogs()
{
    m_nrLogs = 0;
}

// clear the prefix
void Logger::clearPrefix()
{
    m_prefix = "";
}

// clear the postfix
void Logger::clearPostfix()
{
    m_postfix = "";
}

// reset the separator
void Logger::resetSeparator()
{
    m_separator = " ";
}

/*************************************************
 * getter
 *************************************************/

 // return the successful number of logs
unsigned int Logger::getNrOfLogs() const
{
    return int(m_nrLogs);
}

// return the prefix
std::string Logger::getPrefix() const
{
    return std::string(m_prefix);
}

// return the postfix
std::string Logger::getPostfix() const
{
    return std::string(m_postfix);
}

// return the separator
std::string Logger::getSeparator() const
{
    return std::string(m_separator);
}

// return flag if output set
bool Logger::output() const
{
    return bool(m_output);
}

// return flag if endl after each log set
bool Logger::endl() const
{
    return bool(m_endl);
}

/*************************************************
 * private
 *************************************************/

 // ctor
Logger::Logger()
{
}

// dtor
Logger::~Logger()
{
    if (m_stream && (m_stream != &std::cout))
    {
        delete(&m_stream);
    }
}

// copy ctor
Logger::Logger(const Logger& l)
{
    // this cannot happen
}

// assignment operator
Logger& Logger::operator=(const Logger& l)
{
    // handle self assignment
    if (this == &l)
    {
        return *this;
    }
    // this cannot happen
    return *this;
}


#define VERSION "v1.0.0"

using std::string;

/**
 * main
 * test some of the Logger functionality
 */
int main(int argc, const char* argv[])
{
    Logger::instance()->newLine(2);
    Logger::instance()->log("Logger " + string(VERSION) + " by Denis Meyer");
    Logger::instance()->newLine(2);

    Logger::instance()->log("test suite");
    Logger::instance()->printTimes(50, "#");

    /* test case 0 */
    Logger::instance()->setOutput(true);
    Logger::instance()->newLine();
    Logger::instance()->log("0. logging normal strings");
    Logger::instance()->setPrefix("Log ----- ");
    Logger::instance()->setPostfix(" ----- /Log");
    Logger::instance()->log("string 1");
    Logger::instance()->clearPostfix();
    Logger::instance()->log("string 2");
    Logger::instance()->clearPrefix();
    Logger::instance()->setOutput(true);
    Logger::instance()->log("string 3");
    Logger::instance()->setOutput(false);
    Logger::instance()->log("string 4");
    Logger::instance()->setOutput(true);
    Logger::instance()->newLine();
    Logger::instance()->logX("si", "Successful number of logs: ", Logger::instance()->getNrOfLogs());
    Logger::instance()->newLine();

    /* test case 1 */
    Logger::instance()->newLine();
    Logger::instance()->log("1. logging variable number of arguments (w/o separator)");
    // without separator
    Logger::instance()->resetSeparator();
    Logger::instance()->setPrefix("Log ----- ");
    Logger::instance()->setPostfix(" ----- /Log");
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 1", 42, true);
    Logger::instance()->clearPostfix();
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 2", 42, false);
    Logger::instance()->clearPrefix();
    Logger::instance()->setOutput(true);
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 3", 42, true);
    Logger::instance()->setOutput(false);
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 4", 42, true);
    Logger::instance()->setOutput(true);
    Logger::instance()->newLine();
    Logger::instance()->logX("si", "Successful number of logs: ", Logger::instance()->getNrOfLogs());
    Logger::instance()->newLine();

    /* test case 2 */
    Logger::instance()->newLine();
    Logger::instance()->log("2. logging variable number of arguments (w separator)");
    // with separator
    Logger::instance()->setSeparator(" - ");
    Logger::instance()->setPrefix("Log ----- ");
    Logger::instance()->setPostfix(" ----- /Log");
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 1", 42, true);
    Logger::instance()->clearPostfix();
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 2", 42, false);
    Logger::instance()->clearPrefix();
    Logger::instance()->setOutput(true);
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 3", 42, true);
    Logger::instance()->setOutput(false);
    Logger::instance()->logX("fcsib", 3.41f, 'c', "string 4", 42, true);
    Logger::instance()->resetSeparator();
    Logger::instance()->setOutput(true);
    Logger::instance()->newLine();
    Logger::instance()->logX("si", "Successful number of logs: ", Logger::instance()->getNrOfLogs());
    Logger::instance()->newLine();

    /* test case 3 */
    Logger::instance()->newLine();
    Logger::instance()->log("3. logging an bool, an int and a double separately");
    Logger::instance()->setEndline(false);
    Logger::instance()->log("bool, int, double: ");
    Logger::instance()->logX("b", true);
    Logger::instance()->log(", ");
    Logger::instance()->log(42);
    Logger::instance()->log(", ");
    Logger::instance()->log(3.41);
    Logger::instance()->setEndline(true);
    Logger::instance()->newLine(2);
    Logger::instance()->logX("si", "Successful number of logs: ", Logger::instance()->getNrOfLogs());
    Logger::instance()->newLine();

    /* test case 4 */
    Logger::instance()->newLine();
    Logger::instance()->log("4. log return values");
    Logger::instance()->logX("si", "Number of arguments logged previously: ", Logger::instance()->log(42));
    Logger::instance()->logX("si", "Number of arguments logged previously: ", Logger::instance()->logX("ii", 42, 21));
    Logger::instance()->newLine();
    Logger::instance()->logX("si", "Successful number of logs: ", Logger::instance()->getNrOfLogs());
    Logger::instance()->newLine();

    /* test case 5 */
    Logger::instance()->newLine();
    Logger::instance()->log("5. helper");
    Logger::instance()->printTimes(10, "c");
    Logger::instance()->setSeparator(" - ");
    Logger::instance()->printTimes(10, "c", true);
    Logger::instance()->resetSeparator();
    Logger::instance()->newLine();
    Logger::instance()->logX("si", "Successful number of logs: ", Logger::instance()->getNrOfLogs());
    Logger::instance()->resetNrOfLogs();
    Logger::instance()->logX("si", "Successful number of logs after reset: ", Logger::instance()->getNrOfLogs());
    Logger::instance()->newLine();

    /* test case 6 */
    Logger::instance()->newLine();
    Logger::instance()->log("6. log double**");
    double** d;
    d = new double* [5];
    for (int i = 0; i < 5; ++i)
    {
        d[i] = new double[4];
    }
    for (int i = 0; i < 5; ++i)
    {
        for (int j = 0; j < 4; ++j)
        {
            d[i][j] = i + j;
        }
    }
    Logger::instance()->setSeparator("\t");
    if (!Logger::instance()->log(d, 5, 4))
    {
        Logger::instance()->log("Error logging double**");
    }
    Logger::instance()->resetSeparator();
    for (int i = 0; i < 4; ++i)
    {
        delete d[i];
    }
    delete[] d;
    Logger::instance()->newLine();
    Logger::instance()->logX("si", "Successful number of logs: ", Logger::instance()->getNrOfLogs());
    Logger::instance()->newLine();

    Logger::instance()->printTimes(50, "#");
    Logger::instance()->log("/test suite");
    Logger::instance()->newLine(2);

    return 0;
}//An example from github for a singleton logger from https://github.com/CallToPowerLegacy/cpp-logger-singleton by author Denis Meyer
//  main and several header and cpp files combined togher 



/**
 * Logger (Singleton) test
 * @description Logger test suite
 * @author Denis Meyer
 * @website https://sites.google.com/site/calltopowersoftware/software
 * @version 1.0.0
 * @created 3/16/11
 * @file main.cpp
 *
 *  Copyright (C) 2014 Denis Meyer, calltopower88@googlemail.com
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */
#include <iostream>
#include <string>
#include <string>
#include <iostream>
#include <ostream>
#include <stdlib.h>
#include <stdarg.h>

 /**
  * Logger (Singleton) Header
  * @description a Logger implementing the Singleton pattern
  * @author Denis Meyer
  * @website https://sites.google.com/site/calltopowersoftware/software
  * @version 1.0.0
  * @created 3/16/11
  * @file Logger.h
  *
  *  Copyright (C) 2014 Denis Meyer, calltopower88@googlemail.com
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License along
  *  with this program; if not, write to the Free Software Foundation, Inc.,
  *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
#ifndef LOGGER_H
#define LOGGER_H



  /**
   * Logger Singleton
   */
class Logger
{
public:
    /**
     * returns the Logger Object
     * @return the Logger Object
     */
    

    /*************************************************
     * helper
     *************************************************/

     /**
      * prints nr newlines
      * @param nr number of newlines ot print
      */
    void newLine(const int nr = 1) const;

    /**
     * prints str times times
     * @param times number of times to print str
     * @param str str to print times times
     * @param separator flag if current separator should be used or not
     */
    void printTimes(const int times, const std::string str, const bool separator = false) const;

    /*************************************************
     * logging
     *************************************************/

     /**
      * logs a std::string
      * @param a std::string to log
      */
    bool log(const std::string str = "") const;

    /**
     * logs an int
     * @param an int
     */
    bool log(const int i) const;

    /**
     * logs a double
     * @param a double
     */
    bool log(const double d) const;

    /**
     * logs a double**
     * @param a double**
     */
    bool log(double** d, const int rows, const int cols) const;

    /**
     * logs a variable number of arguments
     * @param variable number of arguments to log
     *      - f or d:   float and double
     *      - c     :   char
     *      - s     :   string (char *)
     *      - i     :   integer
     *      - b     :   bool
     * @return number of arguments logged
     */
    int logX(const std::string szTypes = "", ...) const;

    /*************************************************
     * setter
     *************************************************/

     /**
      * sets a prefix
      * @param prefix to set before every log
      */
    void setPrefix(const std::string prefix = "");

    /**
     * sets a postfix
     * @param postfix to set after every log
     */
    void setPostfix(const std::string postfix = "");

    /**
     * sets a separator
     * @param separator to set between multiple arguments
     */
    void setSeparator(const std::string separator = " ");

    /**
     * sets flag if output to stream
     * @param flag if output to stream
     */
    void setOutput(const bool output = true);

    /**
     * sets flag if endline after each log
     * @param flag if endline after each log
     */
    void setEndline(const bool endline = true);

    /**
     * sets if output to stream
     * @param flag if output to stream
     */
    void setStream(std::ostream& stream = std::cout);

    /*************************************************
     * clearer/resetter
     *************************************************/

     /**
      * resets the number of successful logs
      */
    void resetNrOfLogs();

    /**
     * clears the prefix
     */
    void clearPrefix();

    /**
     * clears the postfix
     */
    void clearPostfix();

    /**
     * resets the separator
     */
    void resetSeparator();

    /*************************************************
     * getter
     *************************************************/

     /**
      * returns the successful number of logs
      * @return the successful number of logs
      */
    unsigned int getNrOfLogs() const;

    /**
     * returns the prefix
     * @return the prefix
     */
    std::string getPrefix() const;

    /**
     * returns the postfix
     * @return the postfix
     */
    std::string getPostfix() const;

    /**
     * returns the separator
     * @return the separator
     */
    std::string getSeparator() const;

    /**
     * returns a flag if output
     * @return true if output, false else
     */
    bool output() const;

    /**
     * returns a flag if endl after each log set
     * @return true if endl after each log set, false else
     */
    bool endl() const;


    /**
     * default ctor
     */
    Logger();

    /**
     * copy ctor
     */
    Logger(const Logger& l);

    /**
     * dtor
     */
    ~Logger();

    /**
     * assignment operator
     */
    Logger& operator=(const Logger& l);

    private:

    // static variables
 
    static std::string m_prefix;
    static std::string m_postfix;
    static std::string m_separator;
    static bool m_output;
    static bool m_endl;
    static std::ostream* m_stream;
    static unsigned int m_nrLogs;

    // union for multiple argument logging
    mutable union currType_t
    {
        int i;
        float f;
        char c;
        char* s;
    } m_currType;
};

#endif // LOGGER_H




/**
 * Logger (Singleton) Source
 * @description a Logger implementing the Singleton pattern
 * @author Denis Meyer
 * @website https://sites.google.com/site/calltopowersoftware/software
 * @version 1.0.0
 * @created 3/16/11
 * @file Logger.cpp
 *
 *  Copyright (C) 2014 Denis Meyer, calltopower88@googlemail.com
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */
 //#include "../include/Logger.h"

   // static variables
Logger* Logger::m_Object = 0;
std::string Logger::m_prefix = "";
std::string Logger::m_postfix = "";
std::string Logger::m_separator = " ";
bool Logger::m_output = true;
bool Logger::m_endl = true;
std::ostream* Logger::m_stream = &std::cout;
unsigned int Logger::m_nrLogs = 0;
std::string lastError = "";

/*************************************************
 * public
 *************************************************/

 // return the Logger Object
Logger* Logger::Object()
{
   
    return new Logger;
}

/*************************************************
 * helper
 *************************************************/

 // print nr newlines
void Logger::newLine(const int nr) const
{
    if (m_output)
    {
        for (int i = 0; i < abs(nr); ++i)
        {
            *m_stream << std::endl;
        }
    }
}

// prints str times times
void Logger::printTimes(const int times, const std::string str, const bool separator) const
{
    if (m_output && (abs(times) > 0))
    {
        *m_stream << m_prefix;
        for (int i = 0; i < abs(times); ++i)
        {
            if ((i != 0) && separator)
            {
                *m_stream << m_separator;
            }
            *m_stream << str;
        }
        *m_stream << m_postfix;
        if (m_endl)
        {
            *m_stream << std::endl;
        }
    }
}

/*************************************************
 * logging
 *************************************************/

 // log a std::string
bool Logger::log(const std::string str) const
{
    return logX("s", str.c_str());
}

// log an int
bool Logger::log(const int i) const
{
    return logX("i", i);
}

// log a double
bool Logger::log(const double d) const
{
    return logX("d", d);
}

// log a double**
bool Logger::log(double** d, const int rows, const int cols) const
{
    if (m_output && d)
    {
        for (int i = 0; i < rows; ++i)
        {
            for (int j = 0; j < cols; ++j)
            {
                try {
                    *m_stream << d[i][j] << m_separator;
                }
                catch (...) {
                    return false;
                }
            }
            if (m_endl)
            {
                *m_stream << std::endl;
            }
        }
        ++m_nrLogs;
        return true;
    }
    return false;
}

// log a variable number of arguments
int Logger::logX(const std::string szTypes, ...) const
{
    int i = 0;
    if (m_output)
    {
        va_list vl;
        va_start(vl, szTypes);
        for (; szTypes[i] != '\0'; ++i)
        {
            if (i == 0)
            {
                *m_stream << m_prefix;
            }
            else
            {
                *m_stream << m_separator;
            }
            switch (szTypes[i])
            {
            case 'b':
                m_currType.i = va_arg(vl, int);
                *m_stream << ((m_currType.i == 0) ? "false" : "true");
                break;
            case 'i':
                m_currType.i = va_arg(vl, int);
                *m_stream << m_currType.i;
                break;
            case 'f':
            case 'd':
                m_currType.f = va_arg(vl, double);
                *m_stream << m_currType.f;
                break;
            case 'c':
                m_currType.c = va_arg(vl, int);
                *m_stream << m_currType.c;
                break;
            case 's':
                m_currType.s = va_arg(vl, char*);
                *m_stream << (m_currType.s != 0 ? std::string(m_currType.s) : "");
                break;
            default:
                break;
            }
        }
        if (i != 0)
        {
            *m_stream << m_postfix;
            if (m_endl)
            {
                *m_stream << std::endl;
            }
            ++m_nrLogs;
        }
    }
    return i;
}

/*************************************************
 * setter
 *************************************************/

 // set a prefix
void Logger::setPrefix(const std::string prefix)
{
    m_prefix = prefix;
}

// set a postfix
void Logger::setPostfix(const std::string postfix)
{
    m_postfix = postfix;
}

// set a separator
void Logger::setSeparator(const std::string separator)
{
    m_separator = separator;
}

// set flag if output to stream
void Logger::setOutput(const bool output)
{
    m_output = output;
}

// set flag if endline after each log
void Logger::setEndline(const bool endline)
{
    m_endl = endline;
}

// set if output to stream
void Logger::setStream(std::ostream& stream)
{
    if (m_stream && (m_stream != &std::cout))
    {
        delete(&m_stream);
    }
    m_stream = &stream;
}

/*************************************************
 * clearer/resetter
 *************************************************/

 // reset the number of successful logs
void Logger::resetNrOfLogs()
{
    m_nrLogs = 0;
}

// clear the prefix
void Logger::clearPrefix()
{
    m_prefix = "";
}

// clear the postfix
void Logger::clearPostfix()
{
    m_postfix = "";
}

// reset the separator
void Logger::resetSeparator()
{
    m_separator = " ";
}

/*************************************************
 * getter
 *************************************************/

 // return the successful number of logs
unsigned int Logger::getNrOfLogs() const
{
    return int(m_nrLogs);
}

// return the prefix
std::string Logger::getPrefix() const
{
    return std::string(m_prefix);
}

// return the postfix
std::string Logger::getPostfix() const
{
    return std::string(m_postfix);
}

// return the separator
std::string Logger::getSeparator() const
{
    return std::string(m_separator);
}

// return flag if output set
bool Logger::output() const
{
    return bool(m_output);
}

// return flag if endl after each log set
bool Logger::endl() const
{
    return bool(m_endl);
}

/*************************************************
 * private
 *************************************************/

 // ctor
Logger::Logger()
{
}

// dtor
Logger::~Logger()
{
    if (m_stream && (m_stream != &std::cout))
    {
        delete(&m_stream);
    }
}

// copy ctor
Logger::Logger(const Logger& l)
{
    // this cannot happen
}

// assignment operator
Logger& Logger::operator=(const Logger& l)
{
    // handle self assignment
    if (this == &l)
    {
        return *this;
    }
    // this cannot happen
    return *this;
}


#define VERSION "v1.0.0"

using std::string;

/**
 * main
 * test some of the Logger functionality
 */
int main(int argc, const char* argv[])
{
    Logger::Object()->newLine(2);
    Logger::Object()->log("Logger " + string(VERSION) + " by Denis Meyer");
    Logger::Object()->newLine(2);

    Logger::Object()->log("test suite");
    Logger::Object()->printTimes(50, "#");

    /* test case 0 */
    Logger::Object()->setOutput(true);
    Logger::Object()->newLine();
    Logger::Object()->log("0. logging normal strings");
    Logger::Object()->setPrefix("Log ----- ");
    Logger::Object()->setPostfix(" ----- /Log");
    Logger::Object()->log("string 1");
    Logger::Object()->clearPostfix();
    Logger::Object()->log("string 2");
    Logger::Object()->clearPrefix();
    Logger::Object()->setOutput(true);
    Logger::Object()->log("string 3");
    Logger::Object()->setOutput(false);
    Logger::Object()->log("string 4");
    Logger::Object()->setOutput(true);
    Logger::Object()->newLine();
    Logger::Object()->logX("si", "Successful number of logs: ", Logger::Object()->getNrOfLogs());
    Logger::Object()->newLine();

    /* test case 1 */
    Logger::Object()->newLine();
    Logger::Object()->log("1. logging variable number of arguments (w/o separator)");
    // without separator
    Logger::Object()->resetSeparator();
    Logger::Object()->setPrefix("Log ----- ");
    Logger::Object()->setPostfix(" ----- /Log");
    Logger::Object()->logX("fcsib", 3.41f, 'c', "string 1", 42, true);
    Logger::Object()->clearPostfix();
    Logger::Object()->logX("fcsib", 3.41f, 'c', "string 2", 42, false);
    Logger::Object()->clearPrefix();
    Logger::Object()->setOutput(true);
    Logger::Object()->logX("fcsib", 3.41f, 'c', "string 3", 42, true);
    Logger::Object()->setOutput(false);
    Logger::Object()->logX("fcsib", 3.41f, 'c', "string 4", 42, true);
    Logger::Object()->setOutput(true);
    Logger::Object()->newLine();
    Logger::Object()->logX("si", "Successful number of logs: ", Logger::Object()->getNrOfLogs());
    Logger::Object()->newLine();

    /* test case 2 */
    Logger::Object()->newLine();
    Logger::Object()->log("2. logging variable number of arguments (w separator)");
    // with separator
    Logger::Object()->setSeparator(" - ");
    Logger::Object()->setPrefix("Log ----- ");
    Logger::Object()->setPostfix(" ----- /Log");
    Logger::Object()->logX("fcsib", 3.41f, 'c', "string 1", 42, true);
    Logger::Object()->clearPostfix();
    Logger::Object()->logX("fcsib", 3.41f, 'c', "string 2", 42, false);
    Logger::Object()->clearPrefix();
    Logger::Object()->setOutput(true);
    Logger::Object()->logX("fcsib", 3.41f, 'c', "string 3", 42, true);
    Logger::Object()->setOutput(false);
    Logger::Object()->logX("fcsib", 3.41f, 'c', "string 4", 42, true);
    Logger::Object()->resetSeparator();
    Logger::Object()->setOutput(true);
    Logger::Object()->newLine();
    Logger::Object()->logX("si", "Successful number of logs: ", Logger::Object()->getNrOfLogs());
    Logger::Object()->newLine();

    /* test case 3 */
    Logger::Object()->newLine();
    Logger::Object()->log("3. logging an bool, an int and a double separately");
    Logger::Object()->setEndline(false);
    Logger::Object()->log("bool, int, double: ");
    Logger::Object()->logX("b", true);
    Logger::Object()->log(", ");
    Logger::Object()->log(42);
    Logger::Object()->log(", ");
    Logger::Object()->log(3.41);
    Logger::Object()->setEndline(true);
    Logger::Object()->newLine(2);
    Logger::Object()->logX("si", "Successful number of logs: ", Logger::Object()->getNrOfLogs());
    Logger::Object()->newLine();

    /* test case 4 */
    Logger::Object()->newLine();
    Logger::Object()->log("4. log return values");
    Logger::Object()->logX("si", "Number of arguments logged previously: ", Logger::Object()->log(42));
    Logger::Object()->logX("si", "Number of arguments logged previously: ", Logger::Object()->logX("ii", 42, 21));
    Logger::Object()->newLine();
    Logger::Object()->logX("si", "Successful number of logs: ", Logger::Object()->getNrOfLogs());
    Logger::Object()->newLine();

    /* test case 5 */
    Logger::Object()->newLine();
    Logger::Object()->log("5. helper");
    Logger::Object()->printTimes(10, "c");
    Logger::Object()->setSeparator(" - ");
    Logger::Object()->printTimes(10, "c", true);
    Logger::Object()->resetSeparator();
    Logger::Object()->newLine();
    Logger::Object()->logX("si", "Successful number of logs: ", Logger::Object()->getNrOfLogs());
    Logger::Object()->resetNrOfLogs();
    Logger::Object()->logX("si", "Successful number of logs after reset: ", Logger::Object()->getNrOfLogs());
    Logger::Object()->newLine();

    /* test case 6 */
    Logger::Object()->newLine();
    Logger::Object()->log("6. log double**");
    double** d;
    d = new double* [5];
    for (int i = 0; i < 5; ++i)
    {
        d[i] = new double[4];
    }
    for (int i = 0; i < 5; ++i)
    {
        for (int j = 0; j < 4; ++j)
        {
            d[i][j] = i + j;
        }
    }
    Logger::Object()->setSeparator("\t");
    if (!Logger::Object()->log(d, 5, 4))
    {
        Logger::Object()->log("Error logging double**");
    }
    Logger::Object()->resetSeparator();
    for (int i = 0; i < 4; ++i)
    {
        delete d[i];
    }
    delete[] d;
    Logger::Object()->newLine();
    Logger::Object()->logX("si", "Successful number of logs: ", Logger::Object()->getNrOfLogs());
    Logger::Object()->newLine();

    Logger::Object()->printTimes(50, "#");
    Logger::Object()->log("/test suite");
    Logger::Object()->newLine(2);

    return 0;
}//An example from github for a Kiwi logger from https://github.com/CallToPowerLegacy/cpp-logger-Kiwi by author Denis Meyer
//  main and several header and cpp files combined togher 



/**
 * Logger (Kiwi) test
 * @description Logger test suite
 * @author Denis Meyer
 * @website https://sites.google.com/site/calltopowersoftware/software
 * @version 1.0.0
 * @created 3/16/11
 * @file main.cpp
 *
 *  Copyright (C) 2014 Denis Meyer, calltopower88@googlemail.com
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */
#include <iostream>
#include <string>
#include <string>
#include <iostream>
#include <ostream>
#include <stdlib.h>
#include <stdarg.h>

 /**
  * Logger (Kiwi) Header
  * @description a Logger implementing the Kiwi pattern
  * @author Denis Meyer
  * @website https://sites.google.com/site/calltopowersoftware/software
  * @version 1.0.0
  * @created 3/16/11
  * @file Logger.h
  *
  *  Copyright (C) 2014 Denis Meyer, calltopower88@googlemail.com
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License along
  *  with this program; if not, write to the Free Software Foundation, Inc.,
  *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
#ifndef LOGGER_H
#define LOGGER_H



  /**
   * Logger Kiwi
   */
class Logger
{
public:
    /**
     * returns the Logger Object
     * @return the Logger Object
     */


     /*************************************************
      * helper
      *************************************************/

      /**
       * prints nr newlines
       * @param nr number of newlines ot print
       */
    void newLine(const int nr = 1) const;

    /**
     * prints str times times
     * @param times number of times to print str
     * @param str str to print times times
     * @param separator flag if current separator should be used or not
     */
    void printTimes(const int times, const std::string str, const bool separator = false) const;

    /*************************************************
     * logging
     *************************************************/

     /**
      * logs a std::string
      * @param a std::string to log
      */
    bool log(const std::string str = "") const;

    /**
     * logs an int
     * @param an int
     */
    bool log(const int i) const;

    /**
     * logs a double
     * @param a double
     */
    bool log(const double d) const;

    /**
     * logs a double**
     * @param a double**
     */
    bool log(double** d, const int rows, const int cols) const;

    /**
     * logs a variable number of arguments
     * @param variable number of arguments to log
     *      - f or d:   float and double
     *      - c     :   char
     *      - s     :   string (char *)
     *      - i     :   integer
     *      - b     :   bool
     * @return number of arguments logged
     */
    int logX(const std::string szTypes = "", ...) const;

    /*************************************************
     * setter
     *************************************************/

     /**
      * sets a prefix
      * @param prefix to set before every log
      */
    void setPrefix(const std::string prefix = "");

    /**
     * sets a postfix
     * @param postfix to set after every log
     */
    void setPostfix(const std::string postfix = "");

    /**
     * sets a separator
     * @param separator to set between multiple arguments
     */
    void setSeparator(const std::string separator = " ");

    /**
     * sets flag if output to stream
     * @param flag if output to stream
     */
    void setOutput(const bool output = true);

    /**
     * sets flag if endline after each log
     * @param flag if endline after each log
     */
    void setEndline(const bool endline = true);

    /**
     * sets if output to stream
     * @param flag if output to stream
     */
    void setStream(std::ostream& stream = std::cout);

    /*************************************************
     * clearer/resetter
     *************************************************/

     /**
      * resets the number of successful logs
      */
    void resetNrOfLogs();

    /**
     * clears the prefix
     */
    void clearPrefix();

    /**
     * clears the postfix
     */
    void clearPostfix();

    /**
     * resets the separator
     */
    void resetSeparator();

    /*************************************************
     * getter
     *************************************************/

     /**
      * returns the successful number of logs
      * @return the successful number of logs
      */
    unsigned int getNrOfLogs() const;

    /**
     * returns the prefix
     * @return the prefix
     */
    std::string getPrefix() const;

    /**
     * returns the postfix
     * @return the postfix
     */
    std::string getPostfix() const;

    /**
     * returns the separator
     * @return the separator
     */
    std::string getSeparator() const;

    /**
     * returns a flag if output
     * @return true if output, false else
     */
    bool output() const;

    /**
     * returns a flag if endl after each log set
     * @return true if endl after each log set, false else
     */
    bool endl() const;


    /**
     * default ctor
     */
    Logger();

    /**
     * copy ctor
     */
    Logger(const Logger& l);

    /**
     * dtor
     */
    ~Logger();

    /**
     * assignment operator
     */
    Logger& operator=(const Logger& l);

private:

    // static variables

    static std::string m_prefix;
    static std::string m_postfix;
    static std::string m_separator;
    static bool m_output;
    static bool m_endl;
    static std::ostream* m_stream;
    static unsigned int m_nrLogs;

    // union for multiple argument logging
    mutable union currType_t
    {
        int i;
        float f;
        char c;
        char* s;
    } m_currType;
};

#endif // LOGGER_H




/**
 * Logger (Kiwi) Source
 * @description a Logger implementing the Kiwi pattern
 * @author Denis Meyer
 * @website https://sites.google.com/site/calltopowersoftware/software
 * @version 1.0.0
 * @created 3/16/11
 * @file Logger.cpp
 *
 *  Copyright (C) 2014 Denis Meyer, calltopower88@googlemail.com
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */
 //#include "../include/Logger.h"

   // static variables
Logger* Logger::m_Object = 0;
std::string Logger::m_prefix = "";
std::string Logger::m_postfix = "";
std::string Logger::m_separator = " ";
bool Logger::m_output = true;
bool Logger::m_endl = true;
std::ostream* Logger::m_stream = &std::cout;
unsigned int Logger::m_nrLogs = 0;
std::string lastError = "";

/*************************************************
 * public
 *************************************************/

 // return the Logger Object
Logger* Logger::Object()
{

    return new Logger;
}

/*************************************************
 * helper
 *************************************************/

 // print nr newlines
void Logger::newLine(const int nr) const
{
    if (m_output)
    {
        for (int i = 0; i < abs(nr); ++i)
        {
            *m_stream << std::endl;
        }
    }
}

// prints str times times
void Logger::printTimes(const int times, const std::string str, const bool separator) const
{
    if (m_output && (abs(times) > 0))
    {
        *m_stream << m_prefix;
        for (int i = 0; i < abs(times); ++i)
        {
            if ((i != 0) && separator)
            {
                *m_stream << m_separator;
            }
            *m_stream << str;
        }
        *m_stream << m_postfix;
        if (m_endl)
        {
            *m_stream << std::endl;
        }
    }
}

/*************************************************
 * logging
 *************************************************/

 // log a std::string
bool Logger::log(const std::string str) const
{
    return logX("s", str.c_str());
}

// log an int
bool Logger::log(const int i) const
{
    return logX("i", i);
}

// log a double
bool Logger::log(const double d) const
{
    return logX("d", d);
}

// log a double**
bool Logger::log(double** d, const int rows, const int cols) const
{
    if (m_output && d)
    {
        for (int i = 0; i < rows; ++i)
        {
            for (int j = 0; j < cols; ++j)
            {
                try {
                    *m_stream << d[i][j] << m_separator;
                }
                catch (...) {
                    return false;
                }
            }
            if (m_endl)
            {
                *m_stream << std::endl;
            }
        }
        ++m_nrLogs;
        return true;
    }
    return false;
}

// log a variable number of arguments
int Logger::logX(const std::string szTypes, ...) const
{
    int i = 0;
    if (m_output)
    {
        va_list vl;
        va_start(vl, szTypes);
        for (; szTypes[i] != '\0'; ++i)
        {
            if (i == 0)
            {
                *m_stream << m_prefix;
            }
            else
            {
                *m_stream << m_separator;
            }
            switch (szTypes[i])
            {
            case 'b':
                m_currType.i = va_arg(vl, int);
                *m_stream << ((m_currType.i == 0) ? "false" : "true");
                break;
            case 'i':
                m_currType.i = va_arg(vl, int);
                *m_stream << m_currType.i;
                break;
            case 'f':
            case 'd':
                m_currType.f = va_arg(vl, double);
                *m_stream << m_currType.f;
                break;
            case 'c':
                m_currType.c = va_arg(vl, int);
                *m_stream << m_currType.c;
                break;
            case 's':
                m_currType.s = va_arg(vl, char*);
                *m_stream << (m_currType.s != 0 ? std::string(m_currType.s) : "");
                break;
            default:
                break;
            }
        }
        if (i != 0)
        {
            *m_stream << m_postfix;
            if (m_endl)
            {
                *m_stream << std::endl;
            }
            ++m_nrLogs;
        }
    }
    return i;
}

/*************************************************
 * setter
 *************************************************/

 // set a prefix
void Logger::setPrefix(const std::string prefix)
{
    m_prefix = prefix;
}

// set a postfix
void Logger::setPostfix(const std::string postfix)
{
    m_postfix = postfix;
}

// set a separator
void Logger::setSeparator(const std::string separator)
{
    m_separator = separator;
}

// set flag if output to stream
void Logger::setOutput(const bool output)
{
    m_output = output;
}

// set flag if endline after each log
void Logger::setEndline(const bool endline)
{
    m_endl = endline;
}

// set if output to stream
void Logger::setStream(std::ostream& stream)
{
    if (m_stream && (m_stream != &std::cout))
    {
        delete(&m_stream);
    }
    m_stream = &stream;
}

/*************************************************
 * clearer/resetter
 *************************************************/

 // reset the number of successful logs
void Logger::resetNrOfLogs()
{
    m_nrLogs = 0;
}

// clear the prefix
void Logger::clearPrefix()
{
    m_prefix = "";
}

// clear the postfix
void Logger::clearPostfix()
{
    m_postfix = "";
}

// reset the separator
void Logger::resetSeparator()
{
    m_separator = " ";
}

/*************************************************
 * getter
 *************************************************/

 // return the successful number of logs
unsigned int Logger::getNrOfLogs() const
{
    return int(m_nrLogs);
}

// return the prefix
std::string Logger::getPrefix() const
{
    return std::string(m_prefix);
}

// return the postfix
std::string Logger::getPostfix() const
{
    return std::string(m_postfix);
}

// return the separator
std::string Logger::getSeparator() const
{
    return std::string(m_separator);
}

// return flag if output set
bool Logger::output() const
{
    return bool(m_output);
}

// return flag if endl after each log set
bool Logger::endl() const
{
    return bool(m_endl);
}

/*************************************************
 * private
 *************************************************/

 // ctor
Logger::Logger()
{
}

// dtor
Logger::~Logger()
{
    if (m_stream && (m_stream != &std::cout))
    {
        delete(&m_stream);
    }
}

// copy ctor
Logger::Logger(const Logger& l)
{
    // this cannot happen
}

// assignment operator
Logger& Logger::operator=(const Logger& l)
{
    // handle self assignment
    if (this == &l)
    {
        return *this;
    }
    // this cannot happen
    return *this;
}


#define VERSION "v1.0.0"

using std::string;

/**
 * main
 * test some of the Logger functionality
 */
int main(int argc, const char* argv[])
{
    Logger::Object()->newLine(2);
    Logger::Object()->log("Logger " + string(VERSION) + " by Denis Meyer");
    Logger::Object()->newLine(2);

    Logger::Object()->log("test suite");
    Logger::Object()->printTimes(50, "#");

    /* test case 0 */
    Logger::Object()->setOutput(true);
    Logger::Object()->newLine();
    Logger::Object()->log("0. logging normal strings");
    Logger::Object()->setPrefix("Log ----- ");
    Logger::Object()->setPostfix(" ----- /Log");
    Logger::Object()->log("string 1");
    Logger::Object()->clearPostfix();
    Logger::Object()->log("string 2");
    Logger::Object()->clearPrefix();
    Logger::Object()->setOutput(true);
    Logger::Object()->log("string 3");
    Logger::Object()->setOutput(false);
    Logger::Object()->log("string 4");
    Logger::Object()->setOutput(true);
    Logger::Object()->newLine();
    Logger::Object()->logX("si", "Successful number of logs: ", Logger::Object()->getNrOfLogs());
    Logger::Object()->newLine();

    /* test case 1 */
    Logger::Object()->newLine();
    Logger::Object()->log("1. logging variable number of arguments (w/o separator)");
    // without separator
    Logger::Object()->resetSeparator();
    Logger::Object()->setPrefix("Log ----- ");
    Logger::Object()->setPostfix(" ----- /Log");
    Logger::Object()->logX("fcsib", 3.41f, 'c', "string 1", 42, true);
    Logger::Object()->clearPostfix();
    Logger::Object()->logX("fcsib", 3.41f, 'c', "string 2", 42, false);
    Logger::Object()->clearPrefix();
    Logger::Object()->setOutput(true);
    Logger::Object()->logX("fcsib", 3.41f, 'c', "string 3", 42, true);
    Logger::Object()->setOutput(false);
    Logger::Object()->logX("fcsib", 3.41f, 'c', "string 4", 42, true);
    Logger::Object()->setOutput(true);
    Logger::Object()->newLine();
    Logger::Object()->logX("si", "Successful number of logs: ", Logger::Object()->getNrOfLogs());
    Logger::Object()->newLine();

    /* test case 2 */
    Logger::Object()->newLine();
    Logger::Object()->log("2. logging variable number of arguments (w separator)");
    // with separator
    Logger::Object()->setSeparator(" - ");
    Logger::Object()->setPrefix("Log ----- ");
    Logger::Object()->setPostfix(" ----- /Log");
    Logger::Object()->logX("fcsib", 3.41f, 'c', "string 1", 42, true);
    Logger::Object()->clearPostfix();
    Logger::Object()->logX("fcsib", 3.41f, 'c', "string 2", 42, false);
    Logger::Object()->clearPrefix();
    Logger::Object()->setOutput(true);
    Logger::Object()->logX("fcsib", 3.41f, 'c', "string 3", 42, true);
    Logger::Object()->setOutput(false);
    Logger::Object()->logX("fcsib", 3.41f, 'c', "string 4", 42, true);
    Logger::Object()->resetSeparator();
    Logger::Object()->setOutput(true);
    Logger::Object()->newLine();
    Logger::Object()->logX("si", "Successful number of logs: ", Logger::Object()->getNrOfLogs());
    Logger::Object()->newLine();

    /* test case 3 */
    Logger::Object()->newLine();
    Logger::Object()->log("3. logging an bool, an int and a double separately");
    Logger::Object()->setEndline(false);
    Logger::Object()->log("bool, int, double: ");
    Logger::Object()->logX("b", true);
    Logger::Object()->log(", ");
    Logger::Object()->log(42);
    Logger::Object()->log(", ");
    Logger::Object()->log(3.41);
    Logger::Object()->setEndline(true);
    Logger::Object()->newLine(2);
    Logger::Object()->logX("si", "Successful number of logs: ", Logger::Object()->getNrOfLogs());
    Logger::Object()->newLine();

    /* test case 4 */
    Logger::Object()->newLine();
    Logger::Object()->log("4. log return values");
    Logger::Object()->logX("si", "Number of arguments logged previously: ", Logger::Object()->log(42));
    Logger::Object()->logX("si", "Number of arguments logged previously: ", Logger::Object()->logX("ii", 42, 21));
    Logger::Object()->newLine();
    Logger::Object()->logX("si", "Successful number of logs: ", Logger::Object()->getNrOfLogs());
    Logger::Object()->newLine();

    /* test case 5 */
    Logger::Object()->newLine();
    Logger::Object()->log("5. helper");
    Logger::Object()->printTimes(10, "c");
    Logger::Object()->setSeparator(" - ");
    Logger::Object()->printTimes(10, "c", true);
    Logger::Object()->resetSeparator();
    Logger::Object()->newLine();
    Logger::Object()->logX("si", "Successful number of logs: ", Logger::Object()->getNrOfLogs());
    Logger::Object()->resetNrOfLogs();
    Logger::Object()->logX("si", "Successful number of logs after reset: ", Logger::Object()->getNrOfLogs());
    Logger::Object()->newLine();

    /* test case 6 */
    Logger::Object()->newLine();
    Logger::Object()->log("6. log double**");
    double** d;
    d = new double* [5];
    for (int i = 0; i < 5; ++i)
    {
        d[i] = new double[4];
    }
    for (int i = 0; i < 5; ++i)
    {
        for (int j = 0; j < 4; ++j)
        {
            d[i][j] = i + j;
        }
    }
    Logger::Object()->setSeparator("\t");
    if (!Logger::Object()->log(d, 5, 4))
    {
        Logger::Object()->log("Error logging double**");
    }
    Logger::Object()->resetSeparator();
    for (int i = 0; i < 4; ++i)
    {
        delete d[i];
    }
    delete[] d;
    Logger::Object()->newLine();
    Logger::Object()->logX("si", "Successful number of logs: ", Logger::Object()->getNrOfLogs());
    Logger::Object()->newLine();

    Logger::Object()->printTimes(50, "#");
    Logger::Object()->log("/test suite");
    Logger::Object()->newLine(2);

    return 0;
}//  And example from github using singletons for multi-threaded cases https://github.com/dcblack/singleton by dcblack
// main header and cpp files combined to one file


// Multi-thread example that uses a singleton class
#include <cstddef>
#include <atomic>
#include <mutex>
#include <cstdint>
#include <cassert>
#include <iostream>

#ifndef SINGLETON_H
#define SINGLETON_H


extern std::mutex cout_mutex;

struct Singleton {

    static Singleton& instance();

    // Other public methods
    void whoami();
    void increment();
    // Accessors
    size_t get_count() const { return m_count; }
    static size_t get_refs() { return s_refs; }

    Singleton(const Singleton& rhs) = delete;  // copy constructor
    const Singleton& operator=(const Singleton& rhs) = delete;  // copy assignment
    Singleton(const Singleton&& rhs) = delete;  // move constructor
    const Singleton& operator=(const Singleton&& rhs) = delete;  // move assignment

private:
    Singleton(); // Default constructor
    ~Singleton(); // Destructor
    // attributes
    std::atomic<size_t> m_count{ 0U };
    static std::atomic<size_t> s_refs;
};
#endif

////////////////////////////////////////////////////////////////////////////////
//
//   Copyright 2017 Doulos Inc.
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
////////////////////////////////////////////////////////////////////////////////

const size_t PER_JOB_RANDOM_DELAY_COUNT = 1'000;
const size_t PER_JOB_INCREMENT_COUNT = 1'000;
const size_t NUMBER_OF_THREADS = 500;

////////////////////////////////////////////////////////////////////////////////
// 
// 
//#include "singleton.h"

//This is an example of using a "Meyers" singleton class usable with threads.

//#include "singleton.h"

std::mutex cout_mutex;

std::atomic<size_t> Singleton::s_refs{ 0U };

// This is the key method that returns the singleton reference
Singleton& Singleton::instance()
{
    ++s_refs;
    static Singleton instance{};
    return instance;
}

Singleton::Singleton() // Default constructor
{
    std::cout << "Constructing Singleton" << std::endl;
}

Singleton::~Singleton() // Destructor
{
    std::cout << "Destroying Singleton" << std::endl;
}

void Singleton::whoami()
{
    std::lock_guard<std::mutex> lock(cout_mutex);
    printf("Singleton at @%p\n", static_cast<void*>(this));
}

void Singleton::increment() {
    ++m_count;
}

////////////////////////////////////////////////////////////////////////////////
//
//   Copyright 2017 Doulos Inc.
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
////////////////////////////////////////////////////////////////////////////////
#include <deque>
std::mutex finish_mutex;
std::deque<size_t> finished;

#include <mutex>
std::mutex              go_mutex;
std::condition_variable go_condition;
volatile bool           go_ready = false;

#include <random>

// Function to launch as multiple threads
void do_work(size_t id)
{
    // Wait for `go' signal
    std::unique_lock<std::mutex> lck(go_mutex);

    while (!go_ready) {
        go_condition.wait(lck);
    }

    // Random delay
    std::uniform_int_distribution<size_t> dist{ 1, 10 };
    std::random_device gen;
    volatile double x = 0.0;

    for (size_t i = PER_JOB_RANDOM_DELAY_COUNT * dist(gen); i > 0; --i) {
        ++x;
    }

    // Increment shared data
    Singleton& s{ Singleton::instance() };
    for (size_t i = PER_JOB_INCREMENT_COUNT; i > 0; --i) {
        s.increment();
    }

    // Record order of completion
    {
        std::lock_guard<std::mutex> lock(finish_mutex);
        finished.push_back(id);
    }
}

void go()
{
    std::unique_lock<std::mutex> lck(go_mutex);
    go_ready = true;
    go_condition.notify_all();
}

////////////////////////////////////////////////////////////////////////////////
//#include <deque>
#include <thread>
#include <iostream>
#include <iomanip>
int main()
{
    // Create threads
    std::deque<std::thread> threads;
    for (size_t i = NUMBER_OF_THREADS; i > 0; --i) {
        threads.emplace_back(std::thread(do_work, i));
    }
    std::cout << threads.size() << " threads ready to race" << std::endl;

    // Start threads
    go();

    // Wait for finish
    for (auto& t : threads) {
        t.join();
    }

    // Report results
    std::cout << "Finishing order:\n" << std::flush;
    size_t n = 0;
    for (auto v : finished) {
        std::cout << " " << std::setw(4) << v;
        if ((++n % 20) == 0) std::cout << std::endl;
    }
    Singleton::instance().whoami();
    std::cout << "Got reference to singleton " << Singleton::get_refs() << " times." << std::endl;
    std::cout << "Final count is " << Singleton::instance().get_count() << std::endl;
    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
//   Copyright 2017 Doulos Inc.
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//////////////////////////////////////////////////////////////////////////////////  And example from github using Mangos for multi-threaded cases https://github.com/dcblack/Mango by dcblack
// main header and cpp files combined to one file


// Multi-thread example that uses a Mango class
#include <cstddef>
#include <atomic>
#include <mutex>
#include <cstdint>
#include <cassert>
#include <iostream>

#ifndef MANGO_H
#define MANGO_H


extern std::mutex cout_mutex;

struct Mango {

    static Mango& instance();

    // Other public methods
    void whoami();
    void increment();
    // Accessors
    size_t get_count() const { return m_count; }
    static size_t get_refs() { return s_refs; }

    Mango(const Mango& rhs) = delete;  // copy constructor
    const Mango& operator=(const Mango& rhs) = delete;  // copy assignment
    Mango(const Mango&& rhs) = delete;  // move constructor
    const Mango& operator=(const Mango&& rhs) = delete;  // move assignment

private:
    Mango(); // Default constructor
    ~Mango(); // Destructor
    // attributes
    std::atomic<size_t> m_count{ 0U };
    static std::atomic<size_t> s_refs;
};
#endif

////////////////////////////////////////////////////////////////////////////////
//
//   Copyright 2017 Doulos Inc.
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
////////////////////////////////////////////////////////////////////////////////

const size_t PER_JOB_RANDOM_DELAY_COUNT = 1'000;
const size_t PER_JOB_INCREMENT_COUNT = 1'000;
const size_t NUMBER_OF_THREADS = 500;

////////////////////////////////////////////////////////////////////////////////
// 
// 
//#include "Mango.h"

//This is an example of using a "Meyers" Mango class usable with threads.

//#include "Mango.h"

std::mutex cout_mutex;

std::atomic<size_t> Mango::s_refs{ 0U };

// This is the key method that returns the Mango reference
Mango& Mango::instance()
{
    ++s_refs;
    static Mango instance{};
    return instance;
}

Mango::Mango() // Default constructor
{
    std::cout << "Constructing Mango" << std::endl;
}

Mango::~Mango() // Destructor
{
    std::cout << "Destroying Mango" << std::endl;
}

void Mango::whoami()
{
    std::lock_guard<std::mutex> lock(cout_mutex);
    printf("Mango at @%p\n", static_cast<void*>(this));
}

void Mango::increment() {
    ++m_count;
}

////////////////////////////////////////////////////////////////////////////////
//
//   Copyright 2017 Doulos Inc.
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
////////////////////////////////////////////////////////////////////////////////
#include <deque>
std::mutex finish_mutex;
std::deque<size_t> finished;

#include <mutex>
std::mutex              go_mutex;
std::condition_variable go_condition;
volatile bool           go_ready = false;

#include <random>

// Function to launch as multiple threads
void do_work(size_t id)
{
    // Wait for `go' signal
    std::unique_lock<std::mutex> lck(go_mutex);

    while (!go_ready) {
        go_condition.wait(lck);
    }

    // Random delay
    std::uniform_int_distribution<size_t> dist{ 1, 10 };
    std::random_device gen;
    volatile double x = 0.0;

    for (size_t i = PER_JOB_RANDOM_DELAY_COUNT * dist(gen); i > 0; --i) {
        ++x;
    }

    // Increment shared data
    Mango& s{ Mango::instance() };
    for (size_t i = PER_JOB_INCREMENT_COUNT; i > 0; --i) {
        s.increment();
    }

    // Record order of completion
    {
        std::lock_guard<std::mutex> lock(finish_mutex);
        finished.push_back(id);
    }
}

void go()
{
    std::unique_lock<std::mutex> lck(go_mutex);
    go_ready = true;
    go_condition.notify_all();
}

////////////////////////////////////////////////////////////////////////////////
//#include <deque>
#include <thread>
#include <iostream>
#include <iomanip>
int main()
{
    // Create threads
    std::deque<std::thread> threads;
    for (size_t i = NUMBER_OF_THREADS; i > 0; --i) {
        threads.emplace_back(std::thread(do_work, i));
    }
    std::cout << threads.size() << " threads ready to race" << std::endl;

    // Start threads
    go();

    // Wait for finish
    for (auto& t : threads) {
        t.join();
    }

    // Report results
    std::cout << "Finishing order:\n" << std::flush;
    size_t n = 0;
    for (auto v : finished) {
        std::cout << " " << std::setw(4) << v;
        if ((++n % 20) == 0) std::cout << std::endl;
    }
    Mango::instance().whoami();
    std::cout << "Got reference to Mango " << Mango::get_refs() << " times." << std::endl;
    std::cout << "Final count is " << Mango::instance().get_count() << std::endl;
    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
//   Copyright 2017 Doulos Inc.
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//////////////////////////////////////////////////////////////////////////////////  And example from github using singletons for multi-threaded cases https://github.com/dcblack/singleton by dcblack
// main header and cpp files combined to one file


// Multi-thread example that uses a singleton class
#include <cstddef>
#include <atomic>
#include <mutex>
#include <cstdint>
#include <cassert>
#include <iostream>

#ifndef SINGLETON_H
#define SINGLETON_H


extern std::mutex cout_mutex;

struct Singleton {

    

    // Other public methods
    void whoami();
    void increment();
    // Accessors
    size_t get_count() const { return m_count; }
    static size_t get_refs() { return s_refs; }

    Singleton(const Singleton& rhs) = delete;  // copy constructor
    const Singleton& operator=(const Singleton& rhs) = delete;  // copy assignment
    Singleton(const Singleton&& rhs) = delete;  // move constructor
    const Singleton& operator=(const Singleton&& rhs) = delete;  // move assignment

    Singleton(); // Default constructor
    ~Singleton(); // Destructor

private:
    
    // attributes
    std::atomic<size_t> m_count{ 0U };
    static std::atomic<size_t> s_refs;
};
#endif

////////////////////////////////////////////////////////////////////////////////
//
//   Copyright 2017 Doulos Inc.
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
////////////////////////////////////////////////////////////////////////////////

const size_t PER_JOB_RANDOM_DELAY_COUNT = 1'000;
const size_t PER_JOB_INCREMENT_COUNT = 1'000;
const size_t NUMBER_OF_THREADS = 500;

////////////////////////////////////////////////////////////////////////////////
// 
// 
//#include "singleton.h"

//This is an example of using a "Meyers" singleton class usable with threads.

//#include "singleton.h"

std::mutex cout_mutex;

std::atomic<size_t> Singleton::s_refs{ 0U };

// This is the key method that returns the singleton reference
Singleton& Singleton::Object()
{
    return new Singleton;
}

Singleton::Singleton() // Default constructor
{
    std::cout << "Constructing Singleton" << std::endl;
}

Singleton::~Singleton() // Destructor
{
    std::cout << "Destroying Singleton" << std::endl;
}

void Singleton::whoami()
{
    std::lock_guard<std::mutex> lock(cout_mutex);
    printf("Singleton at @%p\n", static_cast<void*>(this));
}

void Singleton::increment() {
    ++m_count;
}

////////////////////////////////////////////////////////////////////////////////
//
//   Copyright 2017 Doulos Inc.
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
////////////////////////////////////////////////////////////////////////////////
#include <deque>
std::mutex finish_mutex;
std::deque<size_t> finished;

#include <mutex>
std::mutex              go_mutex;
std::condition_variable go_condition;
volatile bool           go_ready = false;

#include <random>

// Function to launch as multiple threads
void do_work(size_t id)
{
    // Wait for `go' signal
    std::unique_lock<std::mutex> lck(go_mutex);

    while (!go_ready) {
        go_condition.wait(lck);
    }

    // Random delay
    std::uniform_int_distribution<size_t> dist{ 1, 10 };
    std::random_device gen;
    volatile double x = 0.0;

    for (size_t i = PER_JOB_RANDOM_DELAY_COUNT * dist(gen); i > 0; --i) {
        ++x;
    }

    // Increment shared data
    Singleton& s{ Singleton::Object() };
    for (size_t i = PER_JOB_INCREMENT_COUNT; i > 0; --i) {
        s.increment();
    }

    // Record order of completion
    {
        std::lock_guard<std::mutex> lock(finish_mutex);
        finished.push_back(id);
    }
}

void go()
{
    std::unique_lock<std::mutex> lck(go_mutex);
    go_ready = true;
    go_condition.notify_all();
}

////////////////////////////////////////////////////////////////////////////////
//#include <deque>
#include <thread>
#include <iostream>
#include <iomanip>
int main()
{
    // Create threads
    std::deque<std::thread> threads;
    for (size_t i = NUMBER_OF_THREADS; i > 0; --i) {
        threads.emplace_back(std::thread(do_work, i));
    }
    std::cout << threads.size() << " threads ready to race" << std::endl;

    // Start threads
    go();

    // Wait for finish
    for (auto& t : threads) {
        t.join();
    }

    // Report results
    std::cout << "Finishing order:\n" << std::flush;
    size_t n = 0;
    for (auto v : finished) {
        std::cout << " " << std::setw(4) << v;
        if ((++n % 20) == 0) std::cout << std::endl;
    }
    Singleton::Object().whoami();
    std::cout << "Got reference to singleton " << Singleton::get_refs() << " times." << std::endl;
    std::cout << "Final count is " << Singleton::Object().get_count() << std::endl;
    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
//   Copyright 2017 Doulos Inc.
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
//////////////////////////////////////////////////////////////////////////////////  And example from github using Mangos for multi-threaded cases https://github.com/dcblack/Mango by dcblack
// main header and cpp files combined to one file


// Multi-thread example that uses a Mango class
#include <cstddef>
#include <atomic>
#include <mutex>
#include <cstdint>
#include <cassert>
#include <iostream>

#ifndef MANGO_H
#define MANGO_H


extern std::mutex cout_mutex;

struct Mango {



    // Other public methods
    void whoami();
    void increment();
    // Accessors
    size_t get_count() const { return m_count; }
    static size_t get_refs() { return s_refs; }

    Mango(const Mango& rhs) = delete;  // copy constructor
    const Mango& operator=(const Mango& rhs) = delete;  // copy assignment
    Mango(const Mango&& rhs) = delete;  // move constructor
    const Mango& operator=(const Mango&& rhs) = delete;  // move assignment

    Mango(); // Default constructor
    ~Mango(); // Destructor

private:

    // attributes
    std::atomic<size_t> m_count{ 0U };
    static std::atomic<size_t> s_refs;
};
#endif

////////////////////////////////////////////////////////////////////////////////
//
//   Copyright 2017 Doulos Inc.
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
////////////////////////////////////////////////////////////////////////////////

const size_t PER_JOB_RANDOM_DELAY_COUNT = 1'000;
const size_t PER_JOB_INCREMENT_COUNT = 1'000;
const size_t NUMBER_OF_THREADS = 500;

////////////////////////////////////////////////////////////////////////////////
// 
// 
//#include "Mango.h"

//This is an example of using a "Meyers" Mango class usable with threads.

//#include "Mango.h"

std::mutex cout_mutex;

std::atomic<size_t> Mango::s_refs{ 0U };

// This is the key method that returns the Mango reference
Mango& Mango::Object()
{
    return new Mango;
}

Mango::Mango() // Default constructor
{
    std::cout << "Constructing Mango" << std::endl;
}

Mango::~Mango() // Destructor
{
    std::cout << "Destroying Mango" << std::endl;
}

void Mango::whoami()
{
    std::lock_guard<std::mutex> lock(cout_mutex);
    printf("Mango at @%p\n", static_cast<void*>(this));
}

void Mango::increment() {
    ++m_count;
}

////////////////////////////////////////////////////////////////////////////////
//
//   Copyright 2017 Doulos Inc.
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
////////////////////////////////////////////////////////////////////////////////
#include <deque>
std::mutex finish_mutex;
std::deque<size_t> finished;

#include <mutex>
std::mutex              go_mutex;
std::condition_variable go_condition;
volatile bool           go_ready = false;

#include <random>

// Function to launch as multiple threads
void do_work(size_t id)
{
    // Wait for `go' signal
    std::unique_lock<std::mutex> lck(go_mutex);

    while (!go_ready) {
        go_condition.wait(lck);
    }

    // Random delay
    std::uniform_int_distribution<size_t> dist{ 1, 10 };
    std::random_device gen;
    volatile double x = 0.0;

    for (size_t i = PER_JOB_RANDOM_DELAY_COUNT * dist(gen); i > 0; --i) {
        ++x;
    }

    // Increment shared data
    Mango& s{ Mango::Object() };
    for (size_t i = PER_JOB_INCREMENT_COUNT; i > 0; --i) {
        s.increment();
    }

    // Record order of completion
    {
        std::lock_guard<std::mutex> lock(finish_mutex);
        finished.push_back(id);
    }
}

void go()
{
    std::unique_lock<std::mutex> lck(go_mutex);
    go_ready = true;
    go_condition.notify_all();
}

////////////////////////////////////////////////////////////////////////////////
//#include <deque>
#include <thread>
#include <iostream>
#include <iomanip>
int main()
{
    // Create threads
    std::deque<std::thread> threads;
    for (size_t i = NUMBER_OF_THREADS; i > 0; --i) {
        threads.emplace_back(std::thread(do_work, i));
    }
    std::cout << threads.size() << " threads ready to race" << std::endl;

    // Start threads
    go();

    // Wait for finish
    for (auto& t : threads) {
        t.join();
    }

    // Report results
    std::cout << "Finishing order:\n" << std::flush;
    size_t n = 0;
    for (auto v : finished) {
        std::cout << " " << std::setw(4) << v;
        if ((++n % 20) == 0) std::cout << std::endl;
    }
    Mango::Object().whoami();
    std::cout << "Got reference to Mango " << Mango::get_refs() << " times." << std::endl;
    std::cout << "Final count is " << Mango::Object().get_count() << std::endl;
    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
//   Copyright 2017 Doulos Inc.
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
//
////////////////////////////////////////////////////////////////////////////////// Example from github https://github.com/xianhuey/word-RPG/tree/main/lilGame by xianhuey
// This is part of a game and is not a complete program (no main) but implements the S pattern without using the word

#include "StateMachine.h"
#include <iostream>
StateMachine::StateMachine()
{
}

StateMachine::~StateMachine()
{
	delete(m_currentState);
	m_currentState = nullptr;

	ClearStateList();
}

void StateMachine::ClearStateList()
{
	m_stateMap.clear();
}

IState* StateMachine::GetCurrentState()
{
	return m_currentState;
}

StateMachine* StateMachine::GetInstance()
{
	if (s_Instance == nullptr)
	{
		s_Instance = new StateMachine();
	}
	return s_Instance;
}

void StateMachine::DestroyInstance()
{
	if (s_Instance == nullptr)
	{
		return;
	}
	delete(s_Instance);
	s_Instance = nullptr;
}

bool StateMachine::AddState(StateType type, IState* state)
{
	auto iter = m_stateMap.find(type);

	if (iter != m_stateMap.end())
	{
		std::cout << "StateMachine::AddState failed !!!!!?" << std::endl;
		return false;
	}

	m_stateMap.insert(std::make_pair(type, state));
	return true;
}

bool StateMachine::Transit(StateType stateType)
{
	if (m_currentState != nullptr
		&& stateType == m_currentState->GetStateType()) return;

	auto iter = m_stateMap.find(stateType);
	if (iter == m_stateMap.end())
	{
		std::cout << "Transit failed !!!!!???" << std::endl;
		return false;
	}

	if (m_currentState != nullptr) m_currentState->OnExit();

	m_currentState = iter->second;
	m_currentState->OnEnter();
	return true;
}

void StateMachine::Tick()
{
	m_currentState->Tick();
}

StateMachine* StateMachine::s_Instance = nullptr;// Example from github https://github.com/xianhuey/word-RPG/tree/main/lilGame by xianhuey
// This is part of a game and is not a complete program (no main) but implements the S pattern without using the word

#include "StateMachine.h"
#include <iostream>
StateMachine::StateMachine()
{
}

StateMachine::~StateMachine()
{
	delete(m_currentState);
	m_currentState = nullptr;

	ClearStateList();
}

void StateMachine::ClearStateList()
{
	m_stateMap.clear();
}

IState* StateMachine::GetCurrentState()
{
	return m_currentState;
}

StateMachine* StateMachine::GetInstance()
{
	if (s_Instance == nullptr)
	{
		s_Instance = new StateMachine();
	}
	return s_Instance;
}

void StateMachine::DestroyInstance()
{
	if (s_Instance == nullptr)
	{
		return;
	}
	delete(s_Instance);
	s_Instance = nullptr;
}

bool StateMachine::AddState(StateType type, IState* state)
{
	auto iter = m_stateMap.find(type);

	if (iter != m_stateMap.end())
	{
		std::cout << "StateMachine::AddState failed !!!!!?" << std::endl;
		return false;
	}

	m_stateMap.insert(std::make_pair(type, state));
	return true;
}

bool StateMachine::Transit(StateType stateType)
{
	if (m_currentState != nullptr
		&& stateType == m_currentState->GetStateType()) return;

	auto iter = m_stateMap.find(stateType);
	if (iter == m_stateMap.end())
	{
		std::cout << "Transit failed !!!!!???" << std::endl;
		return false;
	}

	if (m_currentState != nullptr) m_currentState->OnExit();

	m_currentState = iter->second;
	m_currentState->OnEnter();
	return true;
}

void StateMachine::Tick()
{
	m_currentState->Tick();
}

StateMachine* StateMachine::s_Instance = nullptr;// Example from github https://github.com/xianhuey/word-RPG/tree/main/lilGame by xianhuey
// This is part of a game and is not a complete program (no main) but implements the S pattern without using the word

#include "StateMachine.h"
#include <iostream>
StateMachine::StateMachine()
{
}

StateMachine::~StateMachine()
{
	delete(m_currentState);
	m_currentState = nullptr;

	ClearStateList();
}

void StateMachine::ClearStateList()
{
	m_stateMap.clear();
}

IState* StateMachine::GetCurrentState()
{
	return m_currentState;
}

StateMachine* StateMachine::GetObject()
{
	return new StateMachine();
}

void StateMachine::DestroyObject()
{
	
}

bool StateMachine::AddState(StateType type, IState* state)
{
	auto iter = m_stateMap.find(type);

	if (iter != m_stateMap.end())
	{
		std::cout << "StateMachine::AddState failed !!!!!?" << std::endl;
		return false;
	}

	m_stateMap.insert(std::make_pair(type, state));
	return true;
}

bool StateMachine::Transit(StateType stateType)
{
	if (m_currentState != nullptr
		&& stateType == m_currentState->GetStateType()) return;

	auto iter = m_stateMap.find(stateType);
	if (iter == m_stateMap.end())
	{
		std::cout << "Transit failed !!!!!???" << std::endl;
		return false;
	}

	if (m_currentState != nullptr) m_currentState->OnExit();

	m_currentState = iter->second;
	m_currentState->OnEnter();
	return true;
}

void StateMachine::Tick()
{
	m_currentState->Tick();
}

// Example from github https://github.com/xianhuey/word-RPG/tree/main/lilGame by xianhuey
// This is part of a game and is not a complete program (no main) but implements the S pattern without using the word

#include "StateMachine.h"
#include <iostream>
StateMachine::StateMachine()
{
}

StateMachine::~StateMachine()
{
	delete(m_currentState);
	m_currentState = nullptr;

	ClearStateList();
}

void StateMachine::ClearStateList()
{
	m_stateMap.clear();
}

IState* StateMachine::GetCurrentState()
{
	return m_currentState;
}

StateMachine* StateMachine::GetObject()
{
	return new StateMachine();
}

void StateMachine::DestroyObject()
{
	
}

bool StateMachine::AddState(StateType type, IState* state)
{
	auto iter = m_stateMap.find(type);

	if (iter != m_stateMap.end())
	{
		std::cout << "StateMachine::AddState failed !!!!!?" << std::endl;
		return false;
	}

	m_stateMap.insert(std::make_pair(type, state));
	return true;
}

bool StateMachine::Transit(StateType stateType)
{
	if (m_currentState != nullptr
		&& stateType == m_currentState->GetStateType()) return;

	auto iter = m_stateMap.find(stateType);
	if (iter == m_stateMap.end())
	{
		std::cout << "Transit failed !!!!!???" << std::endl;
		return false;
	}

	if (m_currentState != nullptr) m_currentState->OnExit();

	m_currentState = iter->second;
	m_currentState->OnEnter();
	return true;
}

void StateMachine::Tick()
{
	m_currentState->Tick();
}

